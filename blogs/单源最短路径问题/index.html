<!DOCTYPE html><html lang="en-us" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.5.0 for Hugo" />
  

  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
  

  

  
  
  
    
  
  <meta name="description" content="其实各种算法问题，在《算法导论》中已经有了很精确的定义以及严谨的论证了。但是我个人认为，真正理解一个算法，除了严谨的符号运算之外，还要有一些粗颗粒的认知作为引子，从而能够在必要的时间串起整个论证过程。所以我写下这篇博客，也是对自己认知的检验，如果有幸能被更多人看到，那自然再好不过。" />

  
  <link rel="alternate" hreflang="en-us" href="https://chunxy.github.io/blogs/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/" />

  
  
  
    <meta name="theme-color" content="#1565c0" />
  

  
  
    
    <script src="/js/mathjax-config.js"></script>
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css" media="print" onload="this.media='all'">

  
  
  
    
    

    
    
    
    
      
      
    
    
    

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/libs/chroma/github-light.min.css" title="hl-light" media="print" onload="this.media='all'" >
    <link rel="stylesheet" href="/css/libs/chroma/dracula.min.css" title="hl-dark" media="print" onload="this.media='all'" disabled>

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.84ebe1e3608d6fadc06cb4d7207008ff.css" />

  




<script async src="https://www.googletagmanager.com/gtag/js?id=G-J44SJXJTFD"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
      dataLayer.push(arguments);
  }

  function trackOutboundLink(url, target) {
    gtag('event', 'click', {
         'event_category': 'outbound',
         'event_label': url,
         'transport_type': 'beacon',
         'event_callback': function () {
           if (target !== '_blank') {
             document.location = url;
           }
         }
    });
    console.debug("Outbound link clicked: " + url);
  }

  function onClickCallback(event) {
    if ((event.target.tagName !== 'A') || (event.target.host === window.location.host)) {
      return;
    }
    trackOutboundLink(event.target, event.target.getAttribute('target'));  
  }

  gtag('js', new Date());
  gtag('config', 'G-J44SJXJTFD', {});
  gtag('set', {'cookie_flags': 'SameSite=None;Secure'});

  
  document.addEventListener('click', onClickCallback, false);
</script>


  


  


  




  
  
  

  

  
    <link rel="manifest" href="/manifest.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_huc0707d156b6b3b9945e544e63d06d5e5_16450_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_huc0707d156b6b3b9945e544e63d06d5e5_16450_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="https://chunxy.github.io/blogs/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/" />

  
  
  
  
  
  
  
  
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary_large_image" />
  
  <meta property="og:site_name" content="Chunxy&#39; Website" />
  <meta property="og:url" content="https://chunxy.github.io/blogs/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/" />
  <meta property="og:title" content="单源最短路径问题 | Chunxy&#39; Website" />
  <meta property="og:description" content="其实各种算法问题，在《算法导论》中已经有了很精确的定义以及严谨的论证了。但是我个人认为，真正理解一个算法，除了严谨的符号运算之外，还要有一些粗颗粒的认知作为引子，从而能够在必要的时间串起整个论证过程。所以我写下这篇博客，也是对自己认知的检验，如果有幸能被更多人看到，那自然再好不过。" /><meta property="og:image" content="https://chunxy.github.io/media/sharing.png" />
    <meta property="twitter:image" content="https://chunxy.github.io/media/sharing.png" /><meta property="og:locale" content="en-us" />
  
    
      <meta property="article:published_time" content="2021-06-21T09:33:12&#43;00:00" />
    
    <meta property="article:modified_time" content="2021-06-21T09:33:12&#43;00:00">
  

  



  

  

  

  <title>单源最短路径问题 | Chunxy&#39; Website</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="b2158400d728ad52bd17a581d7d97410" >

  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.2ed908358299dd7ab553faae685c746c.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="Close"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="Search...">
        
      </div>

      
      

      

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    












<header class="header--fixed">
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/">Chunxy&#39; Website</a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="Toggle navigation">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/">Chunxy&#39; Website</a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link  active" href="/blogs/"><span>Blogs</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/notes/"><span>Notes</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/courses/"><span>Courses</span></a>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        

        
        
        <li class="nav-item">
          <a class="nav-link js-search" href="#" aria-label="Search"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        
        
        <li class="nav-item dropdown theme-dropdown">
          <a href="#" class="nav-link" data-toggle="dropdown" aria-haspopup="true" aria-label="Display preferences">
            <i class="fas fa-moon" aria-hidden="true"></i>
          </a>
          <div class="dropdown-menu">
            <a href="#" class="dropdown-item js-set-theme-light">
              <span>Light</span>
            </a>
            <a href="#" class="dropdown-item js-set-theme-dark">
              <span>Dark</span>
            </a>
            <a href="#" class="dropdown-item js-set-theme-auto">
              <span>Automatic</span>
            </a>
          </div>
        </li>
        

        
        

      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    
      
      
      <div class="article-container py-1" style="background: initial">
        
  <nav class="d-none d-md-flex" aria-label="breadcrumb">
    <ol class="breadcrumb">
      
  
    
  
    
  

    <li class="breadcrumb-item">
      <a href="/">
        
          Home
        
      </a>
    </li>
  

    <li class="breadcrumb-item">
      <a href="/blogs/">
        
          Blogs
        
      </a>
    </li>
  

      <li class="breadcrumb-item active" aria-current="page">
        单源最短路径问题
      </li>
    </ol>
  </nav>




      </div>
    

    <article class="article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1>单源最短路径问题</h1>

  

  
    


<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    Jun 21, 2021
  </span>
  

  

  

  
  
  
  

  
  

</div>

    





  
</div>



  <div class="article-container">

    <div class="article-style">
      <p>其实各种算法问题，在《算法导论》中已经有了很精确的定义以及严谨的论证了。但是我个人认为，真正理解一个算法，除了严谨的符号运算之外，还要有一些粗颗粒的认知作为引子，从而能够在必要的时间串起整个论证过程。所以我写下这篇博客，也是对自己认知的检验，如果有幸能被更多人看到，那自然再好不过。</p>
<p>当然，减少严谨的符号运算，并不意味着完全不出现符号，因为算法本身就是对问题的抽象，剥掉这层抽象，就没办法进行架构在抽象之上的信息传递了。</p>
<details class="toc-inpage d-print-none  " open>
  <summary class="font-weight-bold">Table of Contents</summary>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#问题描述及定义">问题描述及定义</a></li>
    <li><a href="#解决思路">解决思路</a></li>
    <li><a href="#正文之前">正文之前</a>
      <ul>
        <li><a href="#负权边">负权边</a></li>
        <li><a href="#负权环路">负权环路</a></li>
        <li><a href="#非负权环路">非负权环路</a></li>
        <li><a href="#放缩操作">放缩操作</a></li>
      </ul>
    </li>
    <li><a href="#解决方法">解决方法</a>
      <ul>
        <li><a href="#bellman-ford算法">Bellman-Ford算法</a></li>
        <li><a href="#dijkstra算法">Dijkstra算法</a></li>
        <li><a href="#有向无环图中的最短路径">有向无环图中的最短路径</a></li>
        <li><a href="#对比">对比</a></li>
      </ul>
    </li>
  </ul>
</nav>
</details>

<p><img src="sssp.png"/></p>
<h2 id="问题描述及定义">问题描述及定义</h2>
<p>单源最短路径问题，旨在求解<strong>带权有向图</strong>（weighted
directed graph）中<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>，从某个<strong>点</strong>（vertex）出发，到图中任意一<strong>点</strong>的最短距离，某些情况下，还需要找出这一条最短距离的<strong>路径</strong>，称之为<strong>最短路径</strong>，若无特殊指明且不致歧义，以下最短路径问题均指代单源最短路径问题。</p>
<p>更严格一些，设<span class="math inline">\(G(V,
E)\)</span>表示带权有向图，<span class="math inline">\(w : E \to
\mathbb{R}\)</span>表示<strong>权重</strong>，<strong>路径</strong><span class="math inline">\(p = \left &lt;v_0, v_1, ... v_k\right
&gt;\)</span>的<strong>距离</strong>定义为： <span class="math display">\[
W(p) = \sum\limits_{i = 1}^k w(v_{k-1}, v_k)
\]</span> 其中， <span class="math display">\[
\begin{gather*}
\forall i \in [0, k], v_i \in V \\
\forall i \in [1, k], (v_{i-1}, v_i) \in E
\end{gather*}
\]</span> 我们从某一点<span class="math inline">\(s\)</span>（叫作<strong>起点</strong>，或者源点）出发，记其到图中任意一<strong>点</strong><span class="math inline">\(v\)</span>的最短路径距离为<span class="math inline">\(\delta(v)\)</span>，<strong>单源最短路径</strong>求解的就是任意一条从<span class="math inline">\(s\)</span>到<span class="math inline">\(v\)</span>的路径<span class="math inline">\(p\)</span>，使得<span class="math inline">\(W(p) =
\delta(v)\)</span>。</p>
<p>为了方便，我们为每一个点<span class="math inline">\(v \in
V\)</span>设立一个中间变量<span class="math inline">\(d\)</span>，用<span class="math inline">\(v.d\)</span>来表示求解过程中的最短距离的<strong>可行上界</strong>，也就是说始终有<span class="math inline">\(\delta(v) \leq v.d\)</span>，算法初始化时，<span class="math inline">\(v.d =
+\infty\)</span>，算法运行过程中，我们通过寻找路径使<span class="math inline">\(v.d\)</span>这个上界不断减小，直到<span class="math inline">\(v.d = \delta(v)\)</span>。</p>
<h2 id="解决思路">解决思路</h2>
<p>最短路径问题（包括多源最短路径问题）都隐含着一个最优子结构（optimal
substructure），即：</p>
<blockquote>
<p>如果<span class="math inline">\(p\)</span>是一条连接两个点的最短路径，那么<span class="math inline">\(p\)</span>的任意一条<strong>子路径</strong>，一定也是连接其两个端点的最短路径。</p>
</blockquote>
<p>这条性质可由反证法轻松得到，也将是后续寻找最短路径所需要理解的一个重要概念。</p>
<h2 id="正文之前">正文之前</h2>
<h3 id="负权边">负权边</h3>
<p>负权边指的是图中某些边的权重为负。虽然负权边不会对最短路径的最优子结构性质产生任何影响，但是后面我们会看到，负权边会导致Dijkstra算法失效。</p>
<h3 id="负权环路">负权环路</h3>
<p>负权环路指的是图中某些边构成一条<strong>环路</strong>（loop），并且这条环路上的所有边的权重相加结果为负。</p>
<p>一旦从起点可以到达这个环路上的点，那么最短路径问题就变得没有意义了：我们可以不断重复地走这条环路，然后
“拐出”
环路，到达目标点，使得到达目标点的路径的权重变得任意小（arbitrarily
short），所以也就不存在什么 “最短路径” 了。</p>
<p>一个成熟的算法应当能够检测出图中是否有可以由<span class="math inline">\(s\)</span>到达的负权环路，如果没有，则算法照常进行；如果有，应予以通报。</p>
<h3 id="非负权环路">非负权环路</h3>
<p>非负权环路指的是图中某些边构成一条<strong>环路</strong>，并且这条环路上的所有边的权重相加的结果大于等于0。</p>
<p>负权环路会使最短路径问题没有意义，那么非负权环路呢？或者说，最短路径是否包含非负权环路呢？</p>
<p>答案是否，如果一条最短路径包含了非负权环路，我们大可将这段环路从路径中
“拿掉”，得到的路径和原路径可以达到同样的终点，并且新路径的权重不大于原路径的权重。</p>
<h3 id="放缩操作">放缩操作</h3>
<p>放缩操作的对象是边，对于边<span class="math inline">\((u,v)\)</span>，放缩操作将检测能否优化点<span class="math inline">\(v\)</span>的上界：</p>
<pre class="pseudocode"><code>RELAX(u, v, w):
if v.d &gt; u.d + w(u, v):
    v.d = u.d + w(u, v)
    v.predecessor = u</code></pre>
<p>即如果路径<span class="math inline">\(s \sim u \to
v\)</span>的长度小于当前<span class="math inline">\(v\)</span>的上界，我们便可以借此优化<span class="math inline">\(v\)</span>的上界，并同时通过将的<span class="math inline">\(v\)</span>前继设为<span class="math inline">\(u\)</span>来记录这一次优化。</p>
<h2 id="解决方法">解决方法</h2>
<h3 id="bellman-ford算法">Bellman-Ford算法</h3>
<p>Bellman-Ford算法是最短路径问题中最为robust的一种了，能处理负权边、能检测负权环路、不要求当前图为有向无环图（directed
acyclic graph）。Bellman-Ford算法基本框架如下：</p>
<blockquote>
<ul>
<li>原图中存在可由起点抵达的负权环路，返回
false，用以告知存在负权环路，最短路径问题无意义</li>
<li>原图中不存在可由起点抵达的负权环路，返回
true，用以告知最短路径问题已解决，并将结果蕴含在相应的数据结构中</li>
</ul>
</blockquote>
<pre class="pseudocode"><code>// 算法主体
for i = 1 to |V| - 1
    for each edge (u, v) in E
        RELAX(u, v, w)

// 检测是否存在负权回路
for each edge (u, v) in E
    if v.d &gt; u.d + w(u, v)
        return false

return true</code></pre>
<ul>
<li><p>算法主体</p>
<p>我们不妨先假设原图中不存在负权环路，先思考Bellman-Ford在解决最短路径问题时的正确性。</p>
<p>根据以上的讨论，任意一点的最短路径中不存在环，故任意一点<span class="math inline">\(t\)</span>的最短路径最多由<span class="math inline">\(|V|-1\)</span>条边，<span class="math inline">\(|V|\)</span>个点构成。设： <span class="math display">\[
p=\left &lt;v_0,v_1, ... v_k\right &gt;，其中v_0 = s，v_k = t
\]</span> 在寻找<span class="math inline">\(t\)</span>的最短路径时，任一<span class="math inline">\(v \in \{u | (u,t) \in E, u.d = \delta(s,
u)\}\)</span>（即此时<span class="math inline">\(v\)</span>的最短路径已找到，且点<span class="math inline">\(v\)</span>有一条连向点<span class="math inline">\(t\)</span>的边） ，都是<span class="math inline">\(v_{k-1}\)</span>（也就是<span class="math inline">\(t\)</span>在其最短路径中的前继）的一个候选，我们需要证明的是，<span class="math inline">\(t\)</span>的实际前继能够在Bellman-Ford算法运行之下被发现，从而被真正地选为<span class="math inline">\(t\)</span>的前继。</p>
<p><img src="bellman.png"/></p>
<p>根据前面的讨论，路径<span class="math inline">\(p\)</span>的前缀<span class="math inline">\(\left &lt;v_0, v_1\right &gt;, \left &lt; v_0,
v_1, v_2\right &gt;...\)</span>分别是<span class="math inline">\(v_1,
v_2, ...\)</span>的最短路径，在外侧第一轮for-loop后，边<span class="math inline">\((v_0, v_1)\)</span>一定会被放缩，而由于<span class="math inline">\(\left &lt;v_0,
v_1\right&gt;\)</span>实际是最短路径，故放缩之后，<span class="math inline">\(v_1.d =
\delta(v_1)\)</span>且将不再变化（因为这已经是最小）；在外侧第二轮for-loop后，边<span class="math inline">\((v_1, v_2)\)</span>一定会被放缩，而由于<span class="math inline">\(\left &lt;v_0, v_1,
v_2\right&gt;\)</span>实际是最短路径，故放缩之后，<span class="math inline">\(v_2.d =
\delta(v_2)\)</span>且将不再变化（因为这已经是最小）<span class="math inline">\(\dots\)</span>如此放缩<span class="math inline">\(k\)</span>轮后，我们便寻找到了<span class="math inline">\(v_1, ...
v_k\)</span>一众节点的最短路径以及其最短路径的前继。</p></li>
<li><p>负权环路检测</p>
<p>至于负权环路检测部分的正确性，则不得不引入一些公式，但其实并不复杂。</p>
<p>假设原图存在可由到达的负权环路<span class="math inline">\(c = \left
&lt;v_0, v_1, ... v_k\right &gt;, v_0 = v_k\)</span>，其中，<span class="math inline">\(W(c) = \sum_{i=0}^{k-1}w(v_i, v_{i+1}) &lt;
0\)</span>。运用反证法，即假设最终不存在<span class="math inline">\((u,v)\)</span>，使得<span class="math inline">\(v.d &gt; u.d + w(u, v)\)</span>，则有： <span class="math display">\[
\begin{aligned}
v_i.d &amp;\leq v_{i-1}.d + w(v_{i-1}, v_i), \forall i \in [1, k]
\Rightarrow  \\
\sum_{i=1}^k v_i.d &amp;\leq \sum_{i=1}^k (v_{i-1}.d + w(v_{i-1},v_i))
\\
v_k.d + \sum_{i=1}^{k-1} v_i.d &amp;\leq v_0.d + \sum_{i=1}^{k-1}
v_{i}.d + \sum_{i=1}^k w(v_{i-1},v_i) \\
0 &amp;\leq \sum_{i=1}^k w(v_{i-1},v_i) = W(c)
\end{aligned}
\]</span> 与<span class="math inline">\(W(c) &lt;
0\)</span>矛盾，故得证。</p></li>
</ul>
<h3 id="dijkstra算法">Dijkstra算法</h3>
<p>Dijkstra算法相对于Bellman-Ford算法来说，可以在时间复杂度上有所优化，但是能够处理的情形也就少了一些：Dijkstra算法不能处理负权边（所以更不用提负权环路了）。Dijkstra算法基本框架如下：</p>
<blockquote>
<ul>
<li>维持一个点集<span class="math inline">\(S\)</span>，点集<span class="math inline">\(S\)</span>由最短路径已确定的点构成；</li>
<li>不断向中加入能够确定最短路径的点，直到所有中的点都被加入。</li>
</ul>
</blockquote>
<pre class="pseudocode"><code>S = {}
Q = G.V
while Q is not empty
    u = EXTRACT-MIN(Q)
    add u to S
    for each v in G.adj[u]
        RELAX(u, v, w)</code></pre>
<p>当然，难点在于如何根据<span class="math inline">\(S\)</span>找出能够确定最短路径的点。寻找到一个点的最短路径的必要条件是：在对到达这个点的最短路径中的前继节点进行放缩操作时，该前继节点的最短路径已经确定，而点集<span class="math inline">\(S\)</span>，正是一个最短路径已经确定的点的集合。</p>
<p><img src="dijkstra.png"/></p>
<p><span class="math inline">\(\forall u \in S\)</span>且<span class="math inline">\((u, t) \in E\)</span>，对<span class="math inline">\((u, t)\)</span>进行放缩后得到的值<span class="math inline">\(t.d\)</span>，都是<span class="math inline">\(\delta(t)\)</span>的一个备选，<span class="math inline">\(S\)</span>中每加入一个点<span class="math inline">\(v\)</span>（非<span class="math inline">\(t\)</span>的点），若边<span class="math inline">\((v,t)\)</span>存在，对该边进行放缩后，<span class="math inline">\(\delta(t)\)</span>的备选（也就是放缩后的<span class="math inline">\(t.d\)</span>）就会多一个，而<span class="math inline">\(\delta(t)\)</span>自然是这些备选中最小的那个。而当<span class="math inline">\(t\)</span>的最短路径确定后，便可以将<span class="math inline">\(t\)</span>加入到点集<span class="math inline">\(S\)</span>中，<span class="math inline">\(S\)</span>不断扩展，直至最终包含整个点集<span class="math inline">\(V\)</span>，也就是所有点的最短路径都被找到。</p>
<p>之前提到过，Dijkstra算法不能处理负权边的情况，但上述
Dijkstra算法的讨论中似乎也没有涉及到负权边，为什么它就不能处理了呢？并且，我们只知道放缩后<span class="math inline">\(t.d\)</span>的是<span class="math inline">\(\delta(t)\)</span>的备选，那么对<span class="math inline">\(t.d\)</span>的放缩要进行到什么时候，才能确认<span class="math inline">\(t.d=\delta(t)\)</span>呢？Dijkstra算法告诉我们，<span class="math inline">\(\forall u \in V - S\)</span>，有<span class="math inline">\(t.d \leq u.d\)</span>时，<span class="math inline">\(\delta(t) = t.d\)</span>，也就是当<span class="math inline">\(t\)</span>的上界小于所有待确认点<span class="math inline">\((V-S)\)</span>的上界时，我们就能确定<span class="math inline">\(t\)</span>的最短路径，也就能够将点<span class="math inline">\(t\)</span>加入到<span class="math inline">\(S\)</span>中。</p>
<p>为什么？如果没有负权边，我们可以会发现，<span class="math inline">\(\forall u \in V - S\)</span>，其上界<span class="math inline">\(u.d\)</span>总是由放缩操作得到的，所以在算法运行过程中，它必然是单调递减的，而且它代表了一条具体的到达<span class="math inline">\(u\)</span>的路径。但为什么<span class="math inline">\(V -
S\)</span>中的所有点的上界的最小值，却能够成为某个特定点<span class="math inline">\(t\)</span>的最短路径呢？</p>
<p>我们来看看<span class="math inline">\(t\)</span>的上界成为最小上界的之前之后都发生了什么，换言之，在此之前，或者在此之后，<span class="math inline">\(t.d\)</span>有没有可能更小？之前是不会更小了，因为我们说过，<span class="math inline">\(t.d\)</span>是单调递减的；那么之后呢？如果在<span class="math inline">\(t\)</span>的上界成为<span class="math inline">\((V-S)\)</span>中的最小上界、从而被加入<span class="math inline">\(S\)</span>之后，我们在新的某一轮中选取另外一个点<span class="math inline">\(u \in V - S\)</span>，作为此轮加入<span class="math inline">\(S\)</span>的点，在随后的操作中<span class="math inline">\(t.d\)</span>会不会因为某个由<span class="math inline">\(u\)</span>出发的放缩操作继续减小呢？</p>
<p>不会的，对于某个新加入的点<span class="math inline">\(u\)</span>，<span class="math inline">\(\delta(u)\)</span>必然不小于任何一个<span class="math inline">\(S\)</span>中的点的最短距离。运用数学归纳法，假设某一时刻<span class="math inline">\(S\)</span>按加入顺序排列为<span class="math inline">\(\{ u_0, \dots, u_k \}\)</span>，且有<span class="math inline">\(u_0.d \le \dots \le u_k.d\)</span>。若<span class="math inline">\(u\)</span>是由<span class="math inline">\(u_k\)</span>“引荐”进来（也就是说进行了<span class="math inline">\(RELAX(u_k, u, w)\)</span>操作）的，则必有<span class="math inline">\(u.d = u_k.d + w(u_k, u) \ge
u_k.d\)</span>；而若<span class="math inline">\(u\)</span>是由非<span class="math inline">\(u_k\)</span>的某个<span class="math inline">\(u_i\)</span>引荐而来，则也必然应该有<span class="math inline">\(u.d \ge u_k.d\)</span>，运用反证法：如果<span class="math inline">\(u.d &lt; u_k.d\)</span>，则在我们的算法中，<span class="math inline">\(u\)</span>至少应该在选择<span class="math inline">\(u_k\)</span>加入的一轮中，因优于<span class="math inline">\(u_k\)</span>被加入，和<span class="math inline">\(S\)</span>的当前情况矛盾，从而得证。</p>
<p>而如果有负权边，则不能保证在后续加入的点的最短距离单调递增，故不能用以上论证来证明Dijkstra算法的正确性了。何况，这种情况下，强行使用Dijkstra算法，很轻易地就能举出反例来证明结果的错误，比如对下图以<span class="math inline">\(s\)</span>为起点应用Dijkstra算法，就会得到错误结果：</p>
<p><img src="counterexample.png"/></p>
<p>当然我们也得证明，每一轮加入新点<span class="math inline">\(t\)</span>时，<span class="math inline">\(t.d =
\delta(t)\)</span>，因为此时虽然<span class="math inline">\(t.d\)</span>达到整个算法流程中的最小，但这个最小值尚未被证明等于<span class="math inline">\(\delta(t)\)</span>。但正如前面所说：</p>
<blockquote>
<p>寻找到一个点的最短路径的必要条件是：在对到达这个点的最短路径中的前继节点进行放缩操作时，该前继节点的最短路径已经确定，而点集<span class="math inline">\(S\)</span>，正是一个最短路径已经确定的点的集合。</p>
</blockquote>
<p>我们可以使用数学归纳法，来证明<span class="math inline">\(S\)</span>始终是一个最短路径已经确定的点的集合，也就是说，假设此时<span class="math inline">\(S\)</span>是一个最短路径已经确定的点的集合，加入<span class="math inline">\(t\)</span>后，<span class="math inline">\(S&#39;\)</span>依然保持它的性质。<span class="math inline">\(t\)</span>前继的候选无非就是图中所有点，我们已经证明，<span class="math inline">\(t.d\)</span>不可能再由于<span class="math inline">\(V-S\)</span>中的点放缩而变小了，所以<span class="math inline">\(t\)</span>在最短路径中的前继只可能来自于<span class="math inline">\(S\)</span>，而<span class="math inline">\(t.d\)</span>正是由<span class="math inline">\(S\)</span>中的点放缩而来，故<span class="math inline">\(t.d\)</span>正式所有可能中最小的那一个，证毕。</p>
<h3 id="有向无环图中的最短路径">有向无环图中的最短路径</h3>
<p>有向无环图，从定义上就排除了负权环路存在的可能，故所有点的最短路径必然存在，问题就在于如何寻找到这些最短路径。</p>
<p>我们当不能对其直接应用Dijkstra算法，因为有向无环图并不排除负权边存在的可能——那就直接用Bellman-Ford算法咯？</p>
<p>也不尽然。有向无环图显然只是Bellman-Ford算法能够处理的情况中的一小部分，并且这一小部分具有一些特殊的性质：无环。设任意一点<span class="math inline">\(t\)</span>的最短路径为<span class="math inline">\(\left &lt;v_0, v_1, ... v_k\right
&gt;\)</span>，其中<span class="math inline">\(v_0 = s，v_k =
t\)</span>，既然不存在环路，从起点<span class="math inline">\(s\)</span>出发，只要沿着边走，一步一步放缩，必然是先放缩边<span class="math inline">\(\left &lt;v_0, v_1\right
&gt;\)</span>并由此得到<span class="math inline">\(v_1.d =
\delta(v_1)\)</span>；然后放缩边<span class="math inline">\(\left
&lt;v_1, v_2\right &gt;\)</span>并由此得到<span class="math inline">\(v_2.d = \delta(v_2)\)</span>……如此放缩<span class="math inline">\(k\)</span>轮后，我们便按顺序寻找到了<span class="math inline">\(v_1, ...
v_k\)</span>一众节点的最短路径以及其最短路径的前继。</p>
<p>“沿着边走”
有一个专业名词，叫做按<strong>拓扑顺序</strong>遍历。事实上，我们放缩过边<span class="math inline">\((v_{i-1},
v_i)\)</span>之后，并不一定要马上放缩边<span class="math inline">\((v_i,
v_{i+1})\)</span>，只要我们能够保证<span class="math inline">\((v_i,
v_{i+1})\)</span>一定在<span class="math inline">\((v_{i-1},
v_i)\)</span>之后放缩即可，至于中间是否穿插其他边的放缩操作，都无所谓。而拓扑顺序正是满足上述性质的一组顺序，为了得到一组拓扑顺序，我们需要对原图进行<strong>拓扑排序</strong>，然后按照得到的拓扑顺序进行放缩。</p>
<p>如何进行拓扑排序呢？实际很简单，首先对原图进行<strong>深度优先遍历</strong>（还有一种基于<strong>入度</strong>的拓扑排序，此处不表），将完成遍历的点依次插入队列的首部，便可得到按照拓扑顺序排列的一个队列，拓扑顺序的实际意义是，如果边<span class="math inline">\((u,v)\)</span>存在，那么对点<span class="math inline">\(u\)</span>的访问必须先于对点<span class="math inline">\(v\)</span>的访问。我们每次从队列中取出一个点，并对从其出发的所有边进行放缩操作即可。虽说拓扑顺序是对点的一个排序，但从该点出发的边和这个点是关联的，所以，先访问点，也就相当于先访问从这个点出发的边了，我们先<span class="math inline">\(v_{i}\)</span>访问，也就必然先于<span class="math inline">\((v_i,v_{i+1})\)</span>放缩<span class="math inline">\((v_{i-1},v_i)\)</span>。</p>
<h3 id="对比">对比</h3>
<table>
<colgroup>
<col style="width: 9%"/>
<col style="width: 26%"/>
<col style="width: 34%"/>
<col style="width: 29%"/>
</colgroup>
<thead>
<tr class="header">
<th>条目</th>
<th>Bellman-Ford</th>
<th>Dijkstra</th>
<th>DAG</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>复杂度</td>
<td><span class="math inline">\(\Theta(|V| |E|)\)</span></td>
<td><span class="math inline">\(\Theta(|E| \log |V|)\)</span></td>
<td><span class="math inline">\(\Theta(|V| + |E|)\)</span></td>
</tr>
<tr class="even">
<td>条件</td>
<td>-</td>
<td>无负权边</td>
<td>有向无环</td>
</tr>
</tbody>
</table>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr/>
<ol>
<li id="fn1" role="doc-endnote"><p>无向图可以很便捷的转换为带权有向图。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    </div>

    






<div class="share-box">
  <ul class="share">
    
      
      
      
        
      
      
      
      <li>
        <a href="https://twitter.com/intent/tweet?url=https://chunxy.github.io/blogs/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/&amp;text=%e5%8d%95%e6%ba%90%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e9%97%ae%e9%a2%98" target="_blank" rel="noopener" class="share-btn-twitter" aria-label="twitter">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.facebook.com/sharer.php?u=https://chunxy.github.io/blogs/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/&amp;t=%e5%8d%95%e6%ba%90%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e9%97%ae%e9%a2%98" target="_blank" rel="noopener" class="share-btn-facebook" aria-label="facebook">
          <i class="fab fa-facebook"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="mailto:?subject=%e5%8d%95%e6%ba%90%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e9%97%ae%e9%a2%98&amp;body=https://chunxy.github.io/blogs/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener" class="share-btn-email" aria-label="envelope">
          <i class="fas fa-envelope"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://www.linkedin.com/shareArticle?url=https://chunxy.github.io/blogs/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/&amp;title=%e5%8d%95%e6%ba%90%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e9%97%ae%e9%a2%98" target="_blank" rel="noopener" class="share-btn-linkedin" aria-label="linkedin-in">
          <i class="fab fa-linkedin-in"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="whatsapp://send?text=%e5%8d%95%e6%ba%90%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e9%97%ae%e9%a2%98%20https://chunxy.github.io/blogs/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener" class="share-btn-whatsapp" aria-label="whatsapp">
          <i class="fab fa-whatsapp"></i>
        </a>
      </li>
    
      
      
      
        
      
      
      
      <li>
        <a href="https://service.weibo.com/share/share.php?url=https://chunxy.github.io/blogs/%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98/&amp;title=%e5%8d%95%e6%ba%90%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e9%97%ae%e9%a2%98" target="_blank" rel="noopener" class="share-btn-weibo" aria-label="weibo">
          <i class="fab fa-weibo"></i>
        </a>
      </li>
    
  </ul>
</div>


























  </div>
</article>
  </div>

  <div class="page-footer">
    
    
    <div class="container">
      <footer class="site-footer">

  



  

  

  

  
  






  
  
  

  
  
    
  
  
    
  

  

  
  <p class="powered-by copyright-license-text">
    © 2024 Chunxy. This work is licensed under <a href="https://creativecommons.org/licenses/by-nc-nd/4.0" rel="noopener noreferrer" target="_blank">CC BY NC ND 4.0</a>
  </p>
  

  <p class="powered-by footer-license-icons">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0" rel="noopener noreferrer" target="_blank" aria-label="Creative Commons">
      <i class="fab fa-creative-commons fa-2x" aria-hidden="true"></i>
      <i class="fab fa-creative-commons-by fa-2x" aria-hidden="true"></i>
      
        <i class="fab fa-creative-commons-nc fa-2x" aria-hidden="true"></i>
      
      
        <i class="fab fa-creative-commons-nd fa-2x" aria-hidden="true"></i>
      
    </a>
  </p>




  <p class="powered-by">
    
    
    
      
      
      
      
      
      
      Published with <a href="https://wowchemy.com/?utm_campaign=poweredby" target="_blank" rel="noopener">Wowchemy</a> — the free, <a href="https://github.com/wowchemy/wowchemy-hugo-themes" target="_blank" rel="noopener">open source</a> website builder that empowers creators.
    
  </p>
</footer>

    </div>
    
  </div>

      

    
    <script src="/js/vendor-bundle.min.6b237408b24ab0ca6e1a289724ba42ac.js"></script>

    
    
    
      

      
      

      

    

    
    
    

    
    

    
    
    
      
      <script id="search-hit-fuse-template" type="text/x-template">
        <div class="search-hit" id="summary-{{key}}">
          <div class="search-hit-content">
            <div class="search-hit-name">
              <a href="{{relpermalink}}">{{title}}</a>
              <div class="article-metadata search-hit-type">{{type}}</div>
              <p class="search-hit-description">{{snippet}}</p>
            </div>
          </div>
        </div>
      </script>
      
        <script src="https://cdn.jsdelivr.net/gh/krisk/Fuse@v3.2.1/dist/fuse.min.js" integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/gh/julmot/mark.js@8.11.1/dist/jquery.mark.min.js" integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin="anonymous"></script>
      
    

    
    

    
    
    
    

    
    
      
      
      
      
      
      
      
    

    

    
    
    
    <script id="page-data" type="application/json">{"use_headroom":true}</script>

    
    
      <script src="/js/wowchemy-headroom.c251366b4128fd5e6b046d4c97a62a51.js" type="module"></script>
    
    
    
    
    
    
    
    
      
      
    
    
    <script src="/en/js/wowchemy.min.06ae91c9ae146f7126c01e6cceb0a4a6.js"></script>

    
    
    
    
    
    






</body>
</html>
