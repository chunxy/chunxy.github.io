<!DOCTYPE html><html lang="en-us" >


<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  
  
    <meta name="generator" content="Wowchemy 5.5.0 for Hugo" />
  

  
  










  







  
  
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
  

  

  
  
  
    
  
  <meta name="description" content="Implementation Trick1 GEMM General Matrix Multiplication describes the implementation tricks that speeds up computation in neural network. Matrix multiplication is a classical, fundamental and established field in both math and computer science." />

  
  <link rel="alternate" hreflang="en-us" href="https://chunxy.github.io/courses/energy-efficient-computing/images/" />

  
  
  
    <meta name="theme-color" content="#1565c0" />
  

  
  
    
    <script src="/js/mathjax-config.js"></script>
  

  

  <link rel="stylesheet" href="/css/vendor-bundle.min.c7b8d9abd591ba2253ea42747e3ac3f5.css" media="print" onload="this.media='all'">

  
  
  
    
    

    
    
    
    
      
      
    
    
    

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/libs/chroma/github-light.min.css" title="hl-light" media="print" onload="this.media='all'" >
    <link rel="stylesheet" href="/css/libs/chroma/dracula.min.css" title="hl-dark" media="print" onload="this.media='all'" disabled>

    
    
    

    

    
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
    
      
      

      
      

      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    
      
      

      
      

      
    
      
      

      
      

      
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.84ebe1e3608d6fadc06cb4d7207008ff.css" />

  




<script async src="https://www.googletagmanager.com/gtag/js?id=G-J44SJXJTFD"></script>
<script>
  window.dataLayer = window.dataLayer || [];

  function gtag() {
      dataLayer.push(arguments);
  }

  function trackOutboundLink(url, target) {
    gtag('event', 'click', {
         'event_category': 'outbound',
         'event_label': url,
         'transport_type': 'beacon',
         'event_callback': function () {
           if (target !== '_blank') {
             document.location = url;
           }
         }
    });
    console.debug("Outbound link clicked: " + url);
  }

  function onClickCallback(event) {
    if ((event.target.tagName !== 'A') || (event.target.host === window.location.host)) {
      return;
    }
    trackOutboundLink(event.target, event.target.getAttribute('target'));  
  }

  gtag('js', new Date());
  gtag('config', 'G-J44SJXJTFD', {});
  gtag('set', {'cookie_flags': 'SameSite=None;Secure'});

  
  document.addEventListener('click', onClickCallback, false);
</script>


  


  


  




  
  
  

  

  
    <link rel="manifest" href="/manifest.webmanifest" />
  

  <link rel="icon" type="image/png" href="/media/icon_huc0707d156b6b3b9945e544e63d06d5e5_16450_32x32_fill_lanczos_center_3.png" />
  <link rel="apple-touch-icon" type="image/png" href="/media/icon_huc0707d156b6b3b9945e544e63d06d5e5_16450_180x180_fill_lanczos_center_3.png" />

  <link rel="canonical" href="https://chunxy.github.io/courses/energy-efficient-computing/images/" />

  
  
  
  
  
  
  
  
    
  
  

  
  
    
    
  
  <meta property="twitter:card" content="summary_large_image" />
  
  <meta property="og:site_name" content="Chunxy&#39; Website" />
  <meta property="og:url" content="https://chunxy.github.io/courses/energy-efficient-computing/images/" />
  <meta property="og:title" content="Note | Chunxy&#39; Website" />
  <meta property="og:description" content="Implementation Trick1 GEMM General Matrix Multiplication describes the implementation tricks that speeds up computation in neural network. Matrix multiplication is a classical, fundamental and established field in both math and computer science." /><meta property="og:image" content="https://chunxy.github.io/media/sharing.png" />
    <meta property="twitter:image" content="https://chunxy.github.io/media/sharing.png" /><meta property="og:locale" content="en-us" />
  
    
      <meta property="article:published_time" content="2022-01-07T13:39:19&#43;00:00" />
    
    <meta property="article:modified_time" content="2022-01-07T13:39:19&#43;00:00">
  

  



  

  

  

  <title>Note | Chunxy&#39; Website</title>
</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper   " data-wc-page-id="b1515df1681b9d5731de111f1ddf4424" >

  
  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.2ed908358299dd7ab553faae685c746c.js"></script>

  


<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="Close"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="Search...">
        
      </div>

      
      

      

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    












<header class="header--fixed">
  <nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
    <div class="container-xl">

      
      <div class="d-none d-lg-inline-flex">
        <a class="navbar-brand" href="/">Chunxy&#39; Website</a>
      </div>
      

      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar-content" aria-controls="navbar-content" aria-expanded="false" aria-label="Toggle navigation">
      <span><i class="fas fa-bars"></i></span>
      </button>
      

      
      <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
        <a class="navbar-brand" href="/">Chunxy&#39; Website</a>
      </div>
      

      
      
      <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

        
        <ul class="navbar-nav d-md-inline-flex">
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/blogs/"><span>Blogs</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link " href="/notes/"><span>Notes</span></a>
          </li>

          
          

          

          
          
          
            
          

          

          
          
          
          

          
            
              
              
            
            
          

          <li class="nav-item">
            <a class="nav-link  active" href="/courses/"><span>Courses</span></a>
          </li>

          
          

        

          
        </ul>
      </div>

      <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

        
        

        
        
        <li class="nav-item">
          <a class="nav-link js-search" href="#" aria-label="Search"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        
        
        
        <li class="nav-item dropdown theme-dropdown">
          <a href="#" class="nav-link" data-toggle="dropdown" aria-haspopup="true" aria-label="Display preferences">
            <i class="fas fa-moon" aria-hidden="true"></i>
          </a>
          <div class="dropdown-menu">
            <a href="#" class="dropdown-item js-set-theme-light">
              <span>Light</span>
            </a>
            <a href="#" class="dropdown-item js-set-theme-dark">
              <span>Dark</span>
            </a>
            <a href="#" class="dropdown-item js-set-theme-auto">
              <span>Automatic</span>
            </a>
          </div>
        </li>
        

        
        

      </ul>

    </div>
  </nav>
</header>


  </div>

  <div class="page-body">
    
    
    

    




<div class="container-fluid docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 docs-sidebar">
      <form class="docs-search d-flex align-items-center">
  <button class="btn docs-toggle d-md-none p-0 mr-md-3 w-100" type="button" data-toggle="collapse" data-target="#docs-nav" aria-controls="docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    <div class="d-flex">
      <span class="d-md-none pl-1 flex-grow-1 text-left overflow-hidden">
        
        
          Efficient Computation
        
      </span>
      <span><i class="fas fa-chevron-down"></i></span>
    </div>
  </button>

  
  <button class="form-control sidebar-search js-search d-none d-md-flex">
    <i class="fas fa-search pr-2"></i>
    <span class="sidebar-search-text">Search...</span>
    <span class="sidebar-search-shortcut">/</span>
  </button>
  
</form>

<nav class="collapse docs-links" id="docs-nav">
  
  
  
  
  
  

  
  
    

    
      

      


  
    
    
    
    
      
    
    

    
      <ul class="nav docs-sidenav">
        <li class=""><a href="/courses/">Courses</a></li>
    
      


  
    
    
    
    
    

    
      <div class="docs-toc-item">
        <a class="docs-toc-link " href="/courses/energy-efficient-computing/"><img src="/media/icons/header1.png" alt="header1.png" class="svg-icon svg-baseline pr-1">Efficient Computation</a>
    
      
        <ul class="nav docs-sidenav">
      


  <li class="active"><a href="/courses/energy-efficient-computing/images/">Note</a></li>

      
        </ul>
      
    

    
      </div>
    



  
    
    
    
    
    

    
      <div class="docs-toc-item">
        <a class="docs-toc-link " href="/courses/foundations-of-optimization/"><img src="/media/icons/header1.png" alt="header1.png" class="svg-icon svg-baseline pr-1">Optimization</a>
    
      
        <ul class="nav docs-sidenav">
      


  <li class=""><a href="/courses/foundations-of-optimization/1-optimization-problem/">1-optimization-problem</a></li>



  <li class=""><a href="/courses/foundations-of-optimization/2-convex-set/">2-convex-set</a></li>



  <li class=""><a href="/courses/foundations-of-optimization/3-convex-function/">3-convex-function</a></li>



  <li class=""><a href="/courses/foundations-of-optimization/4-linear-programming/">4-linear-programming</a></li>



  <li class=""><a href="/courses/foundations-of-optimization/5-conic-linear-programming/">5-conic-linear-programming</a></li>



  <li class=""><a href="/courses/foundations-of-optimization/6-optimizaition-under-uncertainty/">6-optimizaition-under-uncertainty</a></li>



  <li class=""><a href="/courses/foundations-of-optimization/7-quadratically-constrained-quadratic-programming/">7-quadratically-constrained-quadratic-programming</a></li>



  <li class=""><a href="/courses/foundations-of-optimization/8-nonlinear-programming/">8-nonlinear-programming</a></li>

      
        </ul>
      
    

    
      </div>
    



  
    
    
    
    
    

    
      <div class="docs-toc-item">
        <a class="docs-toc-link " href="/courses/machine-learning-theory/"><img src="/media/icons/header1.png" alt="header1.png" class="svg-icon svg-baseline pr-1">Machine Learning Theory</a>
    
      
        <ul class="nav docs-sidenav">
      


  <li class=""><a href="/courses/machine-learning-theory/0-intro/">0-intro</a></li>



  <li class=""><a href="/courses/machine-learning-theory/1-exp-family/">1-exp-family</a></li>



  <li class=""><a href="/courses/machine-learning-theory/2-uniform-convergence/">2-uniform-convergence</a></li>



  <li class=""><a href="/courses/machine-learning-theory/3-rademacher-complexity/">3-rademacher-complexity</a></li>



  <li class=""><a href="/courses/machine-learning-theory/4-vc-dimension/">4-vc-dimension</a></li>



  <li class=""><a href="/courses/machine-learning-theory/5-kernel-methods/">5-kernel-methods</a></li>



  <li class=""><a href="/courses/machine-learning-theory/6-online-learning/">6-online-learning</a></li>

      
        </ul>
      
    

    
      </div>
    



  
    
    
    
    
    

    
      <div class="docs-toc-item">
        <a class="docs-toc-link " href="/courses/advanced-topics-in-distributed-system/"><img src="/media/icons/header1.png" alt="header1.png" class="svg-icon svg-baseline pr-1">Distributed System</a>
    

    
      </div>
    

      
    

    
      </ul>
    

  
</nav>

    </div>

    
    
    <div class="d-none d-xl-block col-xl-2 docs-toc">
      

      <ul class="nav toc-top">
        <li><a href="#" id="back_to_top" class="docs-toc-title">Contents</a></li>
      </ul>

      <nav id="TableOfContents">
  <ul>
    <li><a href="#implementation-trickcomm-lower-bound">Implementation
Trick</a>
      <ul>
        <li><a href="#gemm">GEMM</a></li>
        <li><a href="#direct-convmmdirect-convdirect-mm-1direct-mm-2direct-mm-3">Direct
Conv/MM</a></li>
        <li><a href="#dataflow-optimization">Dataflow Optimization</a></li>
        <li><a href="#elimination-of-multiplicationmnnfaster-mm">Elimination of
Multiplication</a></li>
        <li><a href="#sparse-computationsparse">Sparse Computation[^sparse]</a></li>
        <li><a href="#tensor-virtual-machine">Tensor Virtual Machine</a></li>
        <li><a href="#cuda">CUDA</a></li>
      </ul>
    </li>
    <li><a href="#model-trick">Model Trick</a>
      <ul>
        <li><a href="#sparsification">Sparsification</a></li>
        <li><a href="#pruning">Pruning</a></li>
        <li><a href="#quantizationquant-pytorch">Quantization</a></li>
        <li><a href="#knowledge-distillation">Knowledge Distillation</a></li>
        <li><a href="#network-architecture-search">Network Architecture
Search</a></li>
      </ul>
    </li>
    <li><a href="#useful-links">Useful Links</a></li>
  </ul>
</nav>

      
    </div>
    

    <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 docs-content" role="main">

      <article class="article">

        <div class="docs-article-container">
          
            
  <nav class="d-none d-md-flex" aria-label="breadcrumb">
    <ol class="breadcrumb">
      
  
    
  
    
  
    
  

    <li class="breadcrumb-item">
      <a href="/">
        
          Home
        
      </a>
    </li>
  

    <li class="breadcrumb-item">
      <a href="/courses/">
        
          Courses
        
      </a>
    </li>
  

    <li class="breadcrumb-item">
      <a href="/courses/energy-efficient-computing/">
        
          Efficient Computation
        
      </a>
    </li>
  

      <li class="breadcrumb-item active" aria-current="page">
        Note
      </li>
    </ol>
  </nav>




          
        </div>

        
        

        <div class="docs-article-container">
          <h1>Note</h1>

          <div class="article-style">
            

<h1 id="implementation-trickcomm-lower-bound">Implementation Trick<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></h1>
<h2 id="gemm">GEMM</h2>
<p><strong>Ge</strong>neral <strong>M</strong>atrix
<strong>M</strong>ultiplication describes the implementation tricks that
speeds up computation in neural network. Matrix multiplication is a
classical, fundamental and established field in both math and computer
science. And this is the reason why much effort and interest have been
put into how to further speed up it and how to convert other kinds of
operations into it.</p>
<h3 id="im2col">Im2Col</h3>
<h4 id="single-feature-map-and-kernel">Single Feature Map and
Kernel</h4>
<p>A normal convolution operation will slide a <strong>window</strong>
of the same size as <strong>kernel</strong> (<span class="math inline">\(F: k_h \times k_w\)</span>) through the
<strong>feature map</strong> (<span class="math inline">\(I: i_h \times
i_w\)</span>) in a row-major order (for simplicity, we will take that
stride is <span class="math inline">\(1\)</span> and padding is <span class="math inline">\(0\)</span>). This causes problem because numbers
in a single convolution operation will span multiple columns, due to
which the spatial locality cannot be exploited.</p>
<p>Since the convolution operation is in essence doing the “sum of
products”, we may just as well treat the convolution as dot product
between two vectors.</p>
<p><img src="./im2col.png" style="zoom:50%;"/></p>
<p>To realize it, we can squeeze the kernel into a <span class="math inline">\(k_h k_w \times 1\)</span> column vector and each
window on the feature map to a <span class="math inline">\(1 \times k_h
k_w\)</span> row vector (in memory, a column vector <code>v[N][1]</code>
is no difference from a row vector <code>v[1][N]</code>). Then we stack
these row vectors vertically in the order as their original window would
appear in the convolution. This newly synthesized matrix <span class="math inline">\(L\)</span> is usually called <strong>lowered
matrix</strong>.</p>
<p>As for implementation, we don’t do this “window by window”, because
usually the feature map has a large width, which still introduce the
same issue of not exploiting the spatial locality when accessing across
rows. For each position in the feature map, we can identify all the
positions that it will appear in the lowered matrix in one off. Since
kernel size is usually small, accessing this lowered matrix across rows
causes less cache misses than that in the input.</p>
<p>Treating <span class="math inline">\(L\)</span> as <span class="math inline">\(l_h \times l_w \times k_h \times k_w\)</span>, we
fill up its entries in following way:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> i_h <span class="op">=</span> <span class="dv">9</span><span class="op">,</span> i_w <span class="op">=</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> k_w <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> k_h <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">// For simplicity, set s_w = s_h = 1, padding = 0.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> l_h <span class="op">=</span> i_h <span class="op">-</span> k_h <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> l_w <span class="op">=</span> i_w <span class="op">-</span> k_w <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> im2lower<span class="op">(</span><span class="dt">double</span> I<span class="op">[</span>i_h<span class="op">][</span>i_w<span class="op">],</span> <span class="dt">double</span> L<span class="op">[</span>l_h<span class="op">][</span>l_w<span class="op">][</span>k_h<span class="op">][</span>k_w<span class="op">])</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> h <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> h <span class="op">&lt;</span> i_h<span class="op">;</span> h<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">&lt;</span> i_w<span class="op">;</span> w<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="op">-</span>k_h <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="op">-</span>k_w <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">1</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> <span class="op">(</span>h <span class="op">+</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> h <span class="op">+</span> i <span class="op">&gt;=</span> l_h<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> <span class="op">(</span>w <span class="op">+</span> j <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> w <span class="op">+</span> j <span class="op">&gt;=</span> l_w<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>          L<span class="op">[</span>h <span class="op">+</span> i<span class="op">][</span>w <span class="op">+</span> j<span class="op">][-</span>i<span class="op">][-</span>j<span class="op">]</span> <span class="op">=</span> I<span class="op">[</span>h<span class="op">][</span>w<span class="op">];</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span></code></pre></div>
<h4 id="normal-input-and-filter">Normal Input and Filter</h4>
<p>By far we only consider the case of a single convolution. More often
that not, the real-world convolution is done in batch with multiple
channels, meaning that the input <span class="math inline">\(I\)</span>
is of shape <span class="math inline">\(i_n \times i_c \times i_w \times
i_w\)</span> and filter <span class="math inline">\(F\)</span> is of
shape <span class="math inline">\(f_c \times i_c \times k_h \times
k_w\)</span>. Each of <span class="math inline">\(f_c\)</span> output
channels is obtained as the sum of the one-on-one convolution between
each of the <span class="math inline">\(i_c\)</span> kernels and each of
the <span class="math inline">\(i_c\)</span> channels (which is in
accordance with PyTorch’s <code>Conv2d</code>).</p>
<p>Now we consider the case where there are multiple channels. We
simplify a bit by still setting <span class="math inline">\(i_n =
1\)</span>. As a result, the input <span class="math inline">\(I\)</span> is of shape <span class="math inline">\(i_c \times i_h \times i_w\)</span> and filter
<span class="math inline">\(F\)</span> still remains <span class="math inline">\(f_c \times i_c \times k_h \times k_w\)</span>.
Suppose each feature map contains <span class="math inline">\(d = o_h
\times o_w\)</span> unique kernel windows. Then each transformed channel
should be of shape <span class="math inline">\(d \times k_h k_w\)</span>
(the order of symbols in shortened multiplication matters too; in this
case, <span class="math inline">\(k_h k_w\)</span> indicates we squeeze
by row); each transformed kernel should be of shape <span class="math inline">\(k_h k_w \times 1\)</span>.</p>
<p>The input contains <span class="math inline">\(i_c\)</span> such
transformed <span class="math inline">\(d \times k_h k_w\)</span>
channels. Instead of doing matrix multiplication <span class="math inline">\(i_c\)</span> times, we can concatenate these <span class="math inline">\(i_c\)</span> matrices horizontally to give a
single <span class="math inline">\(d \times (i_c k_h k_w)\)</span>
lowered matrix <span class="math inline">\(L\)</span>.</p>
<p>The filter contains <span class="math inline">\(f_c \times
i_c\)</span> such transformed <span class="math inline">\(k_h k_w \times
1\)</span> kernels. For each output channel, we can concatenate
corresponding <span class="math inline">\(i_c\)</span> kernels
vertically to facilitate the one-on-one convolution, which gives a
single <span class="math inline">\((i_c k_h k_w) \times f_c\)</span>
transformed filter <span class="math inline">\(F&#39;\)</span>.</p>
<p>Now <span class="math inline">\(I \circledast F\)</span> becomes
<span class="math inline">\(L \times F&#39;\)</span>. The output shape
is <span class="math inline">\(d \times f_c\)</span>. Each input image
becomes a <span class="math inline">\(d \times 1\)</span> column vector
finally, which is exactly what “Im2Col” means. This <span class="math inline">\(d \times 1\)</span> vector can be transposed and
then reshaped into <span class="math inline">\(o_h \times o_w\)</span>
to recover the convolution result (no actual transformation has to be
done, just to interpret it this way). Then by applying the Im2Col trick
repeatedly, we can chain up and handle consecutive convolutional
layers.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> i_h <span class="op">=</span> <span class="dv">7</span><span class="op">,</span> i_w <span class="op">=</span> <span class="dv">7</span><span class="op">,</span> i_c <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> k_h <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> k_w <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> f_c <span class="op">=</span> <span class="dv">9</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co">// For simplicity, set s_w = s_h = 1, padding = 0.</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> l_h <span class="op">=</span> i_h <span class="op">-</span> k_h <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> l_w <span class="op">=</span> i_w <span class="op">-</span> k_w <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> im2lower<span class="op">(</span><span class="dt">double</span> I<span class="op">[</span>i_c<span class="op">][</span>i_h<span class="op">][</span>i_w<span class="op">],</span> <span class="dt">double</span> L<span class="op">[</span>l_h<span class="op">][</span>l_w<span class="op">][</span>i_c<span class="op">][</span>k_h<span class="op">][</span>k_w<span class="op">])</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> c <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> c <span class="op">&lt;</span> i_c<span class="op">;</span> c<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> h <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> h <span class="op">&lt;</span> i_h<span class="op">;</span> h<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">&lt;</span> i_w<span class="op">;</span> w<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="op">-</span>k_h <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="op">-</span>k_w <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> <span class="dv">1</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>h <span class="op">+</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> h <span class="op">+</span> i <span class="op">&gt;=</span> l_h<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>w <span class="op">+</span> j <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> w <span class="op">+</span> j <span class="op">&gt;=</span> l_w<span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            L<span class="op">[</span>h <span class="op">+</span> i<span class="op">][</span>w <span class="op">+</span> j<span class="op">][</span>c<span class="op">][-</span>i<span class="op">][-</span>j<span class="op">]</span> <span class="op">=</span> I<span class="op">[</span>c<span class="op">][</span>h<span class="op">][</span>w<span class="op">];</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>          <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> ker2col<span class="op">(</span><span class="dt">double</span> F<span class="op">[</span>f_c<span class="op">][</span>i_c<span class="op">][</span>k_h<span class="op">][</span>k_w<span class="op">],</span> <span class="dt">double</span> K<span class="op">[</span>i_c<span class="op">][</span>k_h<span class="op">][</span>k_w<span class="op">][</span>f_c<span class="op">])</span> <span class="op">{</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> i_c<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> h <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> h <span class="op">&lt;</span> k_h<span class="op">;</span> h<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">&lt;</span> k_w<span class="op">;</span> w<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> f <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> f <span class="op">&lt;</span> f_c<span class="op">;</span> f<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>          K<span class="op">[</span>i<span class="op">][</span>h<span class="op">][</span>w<span class="op">][</span>f<span class="op">]</span> <span class="op">=</span> F<span class="op">[</span>f<span class="op">][</span>i<span class="op">][</span>h<span class="op">][</span>w<span class="op">];</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="mecmec">MEC<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></h3>
<p>Im2Col costs much extra space because most entries in the feature map
appears <span class="math inline">\(k^2\)</span> times in the
transformed lowered matrix. The
<strong>m</strong>emory-<strong>e</strong>fficient
<strong>c</strong>omputation method improves on this by putting the
entries of (say vertically) adjacent windows in one row so that entries
can be reused. By doing so, the transformed kernel row vector will slide
through each row of obtained matrix to compute convolution result.</p>
<p><img src="./mec-basic.svg"/></p>
<p>Again in single feature map and kernel case, the filter <span class="math inline">\(F: k_h \times k_w\)</span> is squeezed to a <span class="math inline">\(k_h k_w \times 1\)</span> column vector. The input
<span class="math inline">\(I: i_h \times i_w\)</span> is converted to
the lowered matrix <span class="math inline">\(L: l_h \times
l_w\)</span> where <span class="math display">\[
l_h = o_w \triangleq (i_w - k_w) / s_w + 1 \\
l_w = i_h k_w, \text{assuming that $k_w \ge s_w$}\\
\]</span> Note that a <span class="math inline">\(k_w\)</span>-width bar
in <span class="math inline">\(I\)</span> (like <span class="math inline">\(A\)</span>) expands to a row in <span class="math inline">\(L\)</span>, and finally a row in <span class="math inline">\(O\)</span>. Treating <span class="math inline">\(L\)</span> as <span class="math inline">\(o_w
\times i_h \times k_w\)</span>, we fill up its entries in following
way:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> i_h <span class="op">=</span> <span class="dv">10</span><span class="op">,</span> i_w <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> k_w <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> s_w <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="dt">const</span> <span class="dt">int</span> o_w <span class="op">=</span> <span class="op">(</span>i_w <span class="op">-</span> k_w<span class="op">)</span> <span class="op">/</span> s_w <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co">// const int l_h = o_w, l_w = i_h * k_w;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> mec<span class="op">(</span><span class="dt">double</span> I<span class="op">[</span>i_h<span class="op">][</span>i_w<span class="op">],</span> <span class="dt">double</span> L<span class="op">[</span>o_w<span class="op">][</span>i_h<span class="op">][</span>k_w<span class="op">])</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">&lt;</span> o_w<span class="op">;</span> w<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> h <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> h <span class="op">&lt;</span> i_h<span class="op">;</span> h<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> k_w<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// I can be transposed first for better spatial locality.</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        L<span class="op">[</span>w<span class="op">][</span>h<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> I<span class="op">[</span>h<span class="op">][</span>s_w <span class="op">*</span> w <span class="op">+</span> i<span class="op">];</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="memory-layout">Memory Layout</h4>
<p>Memory layout is not a standalone method to speed up matrix
computation, but that it cornerstones most implementation tricks.
Different methods may assume different memory layouts.</p>
<p>In convention, the input is of shape <span class="math inline">\(\mathrm{N \times C \times H \times W}\)</span>,
which is the assumed layout of Im2Col. However, the preferred layout for
convolution is usually <span class="math inline">\(\mathrm{N \times H
\times W \times C}\)</span>.</p>
<p>The justification is that, we usually would parallelize by accessing
a window of pixels across all the channels. Though the window spans
multiple columns in both cases, <span class="math inline">\(\mathrm{N
\times C \times H \times W}\)</span> would separate these <span class="math inline">\(C\)</span> windows apart but <span class="math inline">\(\mathrm{N \times H \times W \times C}\)</span>
would otherwise bring all the <span class="math inline">\(c\)</span>
channel values of a pixel in a row, in which case the spatial locality
can be exploited.</p>
<p><span class="math inline">\(\mathrm{N \times H \times W \times
C}\)</span> is the assumed layout by MEC. That is, <span class="math inline">\(I\)</span> is of shape <span class="math inline">\(i_n \times i_h \times i_w \times i_c\)</span> and
<span class="math inline">\(F\)</span> is of shape <span class="math inline">\(k_h \times k_w \times i_c \times f_c\)</span>.
Given <span class="math inline">\(i_n \times i_c\)</span> number of
<span class="math inline">\(o_w \times i_h k_w\)</span> matrices, <span class="math inline">\(L\)</span> is obtained by interleaving
horizontally across channels, and stacked vertically across images. As a
result, <span class="math inline">\(L\)</span> is of shape <span class="math inline">\(i_n o_w \times i_h k_w i_c\)</span>. Accordingly,
<span class="math inline">\(F\)</span> is squeezed to <span class="math inline">\(F&#39;: k_h k_w i_c \times f_c\)</span>.</p>
<p>The example below shows a <span class="math inline">\(3 \times 7
\times 7 \times 1\)</span> input and <span class="math inline">\(3
\times 3 \times 1 \times 1\)</span> filter.</p>
<p><img src="./mec-batch.svg"/></p>
<p>Given the transformed <span class="math inline">\(L\)</span> and
<span class="math inline">\(F&#39;\)</span>, there are two methods for
the remaining dot product (convolution). One is to do <span class="math inline">\(L[0 : i_n o_w, s_w i_h k_w h : s_w i_h k_w h + k_h
k_w c] \times F&#39;\)</span> for <span class="math inline">\(h = 0,
\dots, o_h\)</span>, resulting in a <span class="math inline">\(\mathrm{H \times N \times W \times C}\)</span>
layout (note that each bar in <span class="math inline">\(L\)</span>
expands to a row in <span class="math inline">\(O\)</span>), illustrated
at the upper right in the above figure. If we want to chain up
convolutional layers, we need to convert this layout to <span class="math inline">\(\mathrm{N \times H \times W \times
C}\)</span>.</p>
<p>Another is to do <span class="math inline">\(L[o_w n : o_w (n+1), s_w
i_h k_w h : s_w i_h k_w h + k_h k_w c]\)</span> for <span class="math inline">\(h = 0, \dots, o_h, n = 0,\dots,i_n\)</span>,
resulting in a <span class="math inline">\(\mathrm{N \times H \times W
\times C}\)</span> layout, illustrated at the lower right in the above
figure (the tensor is not properly drawn though; it should have been of
shape <span class="math inline">\(3 \times 5 \times 5\)</span>).</p>
<h2 id="direct-convmmdirect-convdirect-mm-1direct-mm-2direct-mm-3">Direct
Conv/MM<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a><a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a><a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a><a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></h2>
<p>GEMM usually requires extra time and space to do transformation.
In-place convolution/matrix multiplication also have room for
improvement.</p>
<h3 id="loop-reordering">Loop Reordering</h3>
<p>Nested loop is very common in computation. If the effective
statements only appear in the innermost loop, the nesting level of loop
indices can be usually be changed without causing side effect.</p>
<p>One reason to shuffle the loop indices is to better exploit the
spatial locality. Another is to exploit the temporal locality, or called
input reuse. As an example,</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co">// before reordering</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> matmul<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  memset<span class="op">(</span>C<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>C<span class="op">));</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> n<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        C<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">*</span> B<span class="op">[</span>k<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co">// after reordering</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> matmul_ikj<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  memset<span class="op">(</span>C<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>C<span class="op">));</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> n<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        C<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> A<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">*</span> B<span class="op">[</span>k<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>      <span class="op">}</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Before reordering, when innermost loop traverses over <code>k</code>,
there will be one output reuse (<code>C[i][j]</code>), one cache hit
(<code>A[i][k]</code>) and one cache miss (<code>B[k][j]</code>. After
reordering, when innermost loop traverses over <code>j</code>, there
will be one input reuse (<code>A[i][k]</code>) and one cache hit
(<code>B[k][j]</code>).</p>
<h3 id="loop-unrolling">Loop Unrolling</h3>
<p>At the end of a loop, there is usually a branch checking to determine
whether to exit the loop or not. Loop unrolling tries to reduce the
number of branch checking in loop (see <a href="https://www.wikiwand.com/en/Duff&#39;s_device">Duff’s device</a>).
If the number of loops is known in advance, as is usually the case in a
<code>for</code> loop, the number of branch checking can be reduced by
repeating the loop statements several times:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* count &gt; 0 and count % 8 == 0 assumed */</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="co">// before unrolling</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>send<span class="op">(</span>to<span class="op">,</span> from<span class="op">,</span> count<span class="op">)</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="dt">register</span> <span class="dt">short</span> <span class="op">*</span>to<span class="op">,</span> <span class="op">*</span>from<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="dt">register</span> count<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>to <span class="op">=</span> <span class="op">*</span>from<span class="op">++;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">while</span> <span class="op">(--</span>count <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="co">// after unrolling</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>send<span class="op">(</span>to<span class="op">,</span> from<span class="op">,</span> count<span class="op">)</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="dt">register</span> <span class="dt">short</span> <span class="op">*</span>to<span class="op">,</span> <span class="op">*</span>from<span class="op">;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="dt">register</span> count<span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="op">{</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">register</span> n <span class="op">=</span> count <span class="op">/</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">do</span> <span class="op">{</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>to <span class="op">=</span> <span class="op">*</span>from<span class="op">++;</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>to <span class="op">=</span> <span class="op">*</span>from<span class="op">++;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>to <span class="op">=</span> <span class="op">*</span>from<span class="op">++;</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>to <span class="op">=</span> <span class="op">*</span>from<span class="op">++;</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>to <span class="op">=</span> <span class="op">*</span>from<span class="op">++;</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>to <span class="op">=</span> <span class="op">*</span>from<span class="op">++;</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>to <span class="op">=</span> <span class="op">*</span>from<span class="op">++;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">*</span>to <span class="op">=</span> <span class="op">*</span>from<span class="op">++;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">while</span> <span class="op">(--</span>n <span class="op">&gt;</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Manual loop unrolling makes little sense nowadays since modern CPU
can smartly predict the correct branch and modern compiler can
automatically optimize the loop code.</p>
<h3 id="write-caching">Write Caching</h3>
<h3 id="tilingtiled-mmtiled-mm-multithreaded">Tiling<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a><a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></h3>
<p>Tiling utilizes the matrix multiplication property that <span class="math display">\[
\begin{gather*}
A =
\begin{pmatrix}
A_{11} &amp; A_{12} \\
A_{21} &amp; A_{22}
\end{pmatrix},
B =
\begin{pmatrix}
B_{11} &amp; B_{12} \\
B_{21} &amp; B_{22}
\end{pmatrix} \\ \\
A B =
\begin{pmatrix}
A_{11} B_{11} + A_{12} B_{21} &amp; A_{11} B_{12} + A_{12} B_{22} \\
A_{21} B_{11} + A_{22} B_{21} &amp; A_{21} B_{12} + A_{22} B_{22} \\
\end{pmatrix}
\end{gather*}
\]</span></p>
<p>Tiling divides the matrix into blocks that can better fit in the
cache line, so that the temporal locality can be exploited.</p>
<h3 id="vectorization-simdvectorization">Vectorization (SIMD)<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a></h3>
<h3 id="array-packing">Array Packing</h3>
<h2 id="dataflow-optimization">Dataflow Optimization</h2>
<h3 id="systolic-arraysystolic-array">Systolic Array<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a></h3>
<p>Systolic array is dataflow trick implemented in hardware level to
speed up compute-bound task. It is an analog to the heart beat: in
systolic array setting, memory is the heart, which bumps data (blood) to
(usually a regular array of) processing elements (cells) and then
recycle (processing result).</p>
<p>A whole bandwidth of data would certainly entail a bunch of PEs to
digest. These PEs can have local memory and execution kernel, which
means they can be any kind of computing devices. PEs also connect to
each for passing data. All that’s left to do is to properly orchestrate
the data flow.</p>
<p>The crux is that, instead of bumping one piece of data to a single
processing element (PE), bringing the memory bandwidth to the utmost
utilization would be more efficient. Other than that, once data is
brought out from memory, it and its intermediate result can be used
effectively at each PE it passes through.</p>
<h2 id="elimination-of-multiplicationmnnfaster-mm">Elimination of
Multiplication<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a><a href="#fn12" class="footnote-ref" id="fnref12" role="doc-noteref"><sup>12</sup></a></h2>
<p>Multiplication is way more time-consuming than addition. Therefore
generally, we are willing to trade off with more additions for less
multiplications. The two algorithms below can reduce the number of
multiplications in matrix computation.</p>
<h3 id="strassens-algorithmstrassen-implstrassen-analysis">Strassen’s
Algorithm<a href="#fn13" class="footnote-ref" id="fnref13" role="doc-noteref"><sup>13</sup></a><a href="#fn14" class="footnote-ref" id="fnref14" role="doc-noteref"><sup>14</sup></a></h3>
<p>Firstly we look at the <strong>Strassen’s algorithm</strong> of
matrix computation. Suppose we do the matrix multiplication on two
square matrices <span class="math inline">\(M\)</span> and <span class="math inline">\(N\)</span> following the idea of blockwise
multiplication. We split the two matrices into <span class="math display">\[
M = \begin{bmatrix}
A &amp; B \\
C &amp; D
\end{bmatrix},
N = \begin{bmatrix}
E &amp; F \\
G &amp; H
\end{bmatrix}
\]</span> Then we calculate the intermediate matrices <span class="math display">\[
\begin{align*}
S_1 &amp;= (B-D)(G+H) \\
S_2 &amp;= (A+D)(E+H) \\
S_3 &amp;= (A-C)(E+F) \\
S_4 &amp;= (A+B)H \\
S_5 &amp;= A(F-H) \\
S_6 &amp;= D(G-E) \\
S_7 &amp;= (C+D)E \\
\end{align*}
\]</span> And the final result will be <span class="math display">\[
\begin{bmatrix}
A &amp; B \\
C &amp; D
\end{bmatrix}
\begin{bmatrix}
E &amp; F \\
G &amp; H
\end{bmatrix}
=
\begin{bmatrix}
S_1 + S_2 - S_4 + S_6 &amp; S_4 + S_5 \\
S_6 + S_7 &amp; S_2 - S_3 + S_5 - S_7
\end{bmatrix}
\]</span> The derivation of matrix multiplication with Strassen’s
algorithm can be formulated as <span class="math display">\[
T(n) =
\begin{cases}
\Theta(1), &amp; \text{if $n=1$;} \\
7 \Theta(\frac{n}{2}) + \Theta(n^2), &amp; \text{if $n&gt;1$.}
\end{cases}
\]</span> The master theorem provides an asymptotic analysis for
divide-and-conquer recurrence like this. Let <span class="math inline">\(T(n)\)</span> be a monotonically increasing
function that satisfies <span class="math display">\[
T(n) = a T(\frac{n}{b}) + f(n) \\
T(1) = c
\]</span> where <span class="math inline">\(a \ge 1, b \ge 2, c &gt;
0\)</span>. If <span class="math inline">\(f(n) \in \Theta(n^d)\)</span>
where <span class="math inline">\(d \ge 0\)</span>, then <span class="math display">\[
T(n) = \begin{cases}
\Theta(n^d) &amp; \text{if $a &lt; b^d$} \\
\Theta(n^d \log n) &amp; \text{if $a = b^d$} \\
\Theta(n^{\log_b a}) &amp; \text{if $a &gt; b^d$} \\
\end{cases}
\]</span></p>
<p>The time complexity of Strassen’s algorithm is <span class="math inline">\(\Theta(n^{\log_2 7}) \approx
\Theta(n^{2.8074})\)</span>. There are 7 multiplications and 18
additions (recall that subtraction is addition in computer arithmetics)
in Strassen’s algorithm. In usual blockwise matrix multiplication, these
numbers are 8 and 4. These extra 14 additions in Strassen’s algorithm
may drag down its performance when input size is small. Other than that,
the memory access pattern of Strassen’s algorithm is quite chaotic.
There are many temp matrices of different shapes generated during the
execution. Besides, floating-point errors will accumulate in Strassen’s
large number of additions. These factors may constitute the reason why
Stassen algorithm is not widely adopted.</p>
<h3 id="winograd-algorithmwinograd">Winograd Algorithm<a href="#fn15" class="footnote-ref" id="fnref15" role="doc-noteref"><sup>15</sup></a></h3>
<p>In 1-D convolution, let <span class="math inline">\(m\)</span> be the
length of the output vector and <span class="math inline">\(r\)</span>
be the length of kernel. The baseline implementation would require <span class="math inline">\(mr\)</span> multiplications. But it is argued that
the minimum number of required multiplications is <span class="math inline">\(m + r - 1\)</span> (denoted as <span class="math inline">\(F(m,r)\)</span> the corresponding algorithm).</p>
<p>Similarly in 2-D convolution, let <span class="math inline">\(m
\times n\)</span> be the output dimension and <span class="math inline">\(r \times s\)</span> be the kernel dimension. The
baseline implementation would require <span class="math inline">\(m n r
s\)</span> multiplications. But the minimum number of required
multiplications is <span class="math inline">\((m + r - 1)(n + s -
1)\)</span> (denoted as <span class="math inline">\(F(m \times n, r
\times s)\)</span> the corresponding algorithm).</p>
<p>The Winograd paper documents the following algorithm for <span class="math inline">\(F(2,3)\)</span>: <span class="math display">\[
F(2,3) =
\begin{bmatrix}
d_0 &amp; d_1 &amp; d_2 \\
d_1 &amp; d_2 &amp; d_3
\end{bmatrix}
\begin{bmatrix}
g_0 \\
g_1 \\
g_2
\end{bmatrix}
=
\begin{bmatrix}
m_1 + m_2 + m_3 \\
m_2 - m_3 - m_4
\end{bmatrix}
\]</span> where <span class="math display">\[
m_1 = (d_0 - d_2) g_0, m_2 = (d_1 + d_2) \frac{g_0 + g_1 + g_2}{2} \\
m_4 = (d_1 - d_3) g_2, m_3 = (d_2 - d_1) \frac{g_0 - g_1 + g_2}{2}
\]</span> Actually, this can be written in matrix form as <span class="math display">\[
Y =A^T [(G g) \odot (B^T d)]
\]</span> where <span class="math display">\[
B^T =
\begin{bmatrix}
1 &amp; 0 &amp; -1 &amp; 0 \\
0 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; -1 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; -1
\end{bmatrix},
G =
\begin{bmatrix}
1 &amp; 0 &amp; 0 \\
\frac{1}{2} &amp; \frac{1}{2} &amp; \frac{1}{2} \\
\frac{1}{2} &amp; -\frac{1}{2} &amp; \frac{1}{2} \\
0 &amp; 0 &amp; 1
\end{bmatrix} \\
A^T =
\begin{bmatrix}
1 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 1 &amp; -1 &amp; -1
\end{bmatrix}\\
g =
\begin{bmatrix}
g_0 &amp; g_1 &amp; g_2
\end{bmatrix}^T \\
d =
\begin{bmatrix}
d_0 &amp; d_1 &amp; d_2 &amp; d_3
\end{bmatrix}^T
\]</span> <span class="math inline">\(F(m \times m, r \times r)\)</span>
can be built upon <span class="math inline">\(F(m, r)\)</span>. For
example, <span class="math inline">\(F(2 \times 2, 3 \times 3)\)</span>
is <span class="math display">\[
Y&#39; = A^T \left[ [G g G^T] \odot [B^T d B] \right] A
\]</span> <span class="math inline">\(F(m \times n, r \times s)\)</span>
can be built upon <span class="math inline">\(F(m, r)\)</span> and <span class="math inline">\(F(n, s)\)</span>.</p>
<p>Winograd algorithm is great. One problem is that the <span class="math inline">\(A,B,G\)</span> matrix are too specific. For
input/kernel of different sizes, <span class="math inline">\(A,B,G\)</span> will be greatly different. For a
convolutional neural network that involves inputs/kernels of varying
sizes, Winograd algorithm is not suitable for acceleration on
special-purpose hardware, which is usually dedicated to a fixed type of
computation.</p>
<h2 id="sparse-computationsparse">Sparse Computation[^sparse]</h2>
<p>Structured sparsity can reduce computation when there is zero in the
multiplicands. But this involves zero-check for each element of the
filter, which might ruin the CPU pipeline however. To avoid zero-check
in a sparse matrix, we may as well store the positions of all the
nonzero elements. During computation, only involved nonzero elements
will be multiplied and accumulated to obtain the final result.</p>
<h3 id="sparse-matrix-multiplication">Sparse Matrix Multiplication</h3>
<p>For a sparse matrix, we either store it in <strong>compressed sparse
row</strong> (CSR) or <strong>compressed sparse column</strong> (CSC)
(or other formats<a href="#fn16" class="footnote-ref" id="fnref16" role="doc-noteref"><sup>16</sup></a>). That is, for every row/column, we
maintain a linked list whose nodes store the nonzero value and its
offset in this row/column.</p>
<p>The compression is done after training. The choice of CSR or CSC in
matrix multiplication seems arbitrary, so long as one matrix is CSR and
the other is CSC. But in practice, convolution is done row-by-row. We
need to access the feature map across rows more often than across
columns. Thus, feature map is stored in CSR and the filter is stored in
CSC.</p>
<h3 id="sparse-sparse-convolution">Sparse-sparse Convolution</h3>
<p>Sometimes not only the filter, but also the feature map is sparse,
e.g. in point cloud case. We may as well apply the Im2Col and then apply
the sparse matrix multiplication. But better still, we hope to directly
apply the sparse convolution<a href="#fn17" class="footnote-ref" id="fnref17" role="doc-noteref"><sup>17</sup></a><a href="#fn18" class="footnote-ref" id="fnref18" role="doc-noteref"><sup>18</sup></a>
on the original feature map.</p>
<p>But does sparse-sparse convolution always work? It depends. The crux
is that we don’t just carry out a single sparse-sparse convolution.
Modern models consist of multiple layers. We hope the output of each
layer is sparse so that sparse-sparse convolution can be chained up. If
the output of any intermediate layer is not sparse enough, the whole
process becomes pointless.</p>
<h2 id="tensor-virtual-machine">Tensor Virtual Machine</h2>
<p>Current neural network frameworks translate models into a computation
graph in ONNX format, which in turn is translated into hardware
instructions by the compilers from different manufacturers
(e.g. TensorRT for NVIDIA GPU, MNN for ARM Cortex-A CPU, OpenVINO for
Intel CPU).</p>
<h2 id="cuda">CUDA</h2>
<p>Ideally, the computation can be parallelized for greater speedup.
CUDA provides such API for parallel computation on GPU. One key concept
of CUDA is its granularity of execution: grid -&gt; block -&gt; thread
(from coarsest to finest).</p>
<h1 id="model-trick">Model Trick</h1>
<p>Other than implementation tricks, the matrix computation can be sped
up by multiplication with zero. Block of zeros usually allows us to jump
a series of block computation when using the implementation tricks
mentioned before. Other than that, it saves space due to the sparse
matrix storage model (a kind of <strong>model compression</strong>).</p>
<p>It would be great if there are multiple blocks of zeros in the
matrix. Better still, these zeros won’t undermine the model results
much.</p>
<h2 id="sparsification">Sparsification</h2>
<p>Sparsification tries to zero parameters in block during training. It
does so by adding special regularization term to the loss function.
Typical sparsity analysis assumes the linear-regression-like problem.
Denote the original loss as <span class="math inline">\(\ell_w(X,
Y)\)</span> where <span class="math inline">\(\ell\)</span> is the MSE
loss function, <span class="math inline">\(X\)</span> is the data, <span class="math inline">\(Y\)</span> is the target (<span class="math inline">\(Y\)</span> may be a feature map or label vector)
and <span class="math inline">\(w\)</span> is the model parameters
(interpreted as a vector). Then, the problem is formulated as <span class="math display">\[
\min_{w} \ell_w(X, Y) \triangleq ||Y - X w||_F
\]</span> We may force an extra <span class="math inline">\(l_p\)</span>
norm term on <span class="math inline">\(w\)</span>: <span class="math display">\[
\hat \ell_w(X, Y) \triangleq \ell_w(X, Y) + \lambda ||w||_p
\]</span> Note that <span class="math display">\[
||w||_0 = \sum_{i} \mathbb{1}[w_i \ne 0] \\
||w||_1 = \sum_{i} |w_i| \\
||w||_2 = \sqrt{\sum_{i} x_i^2} \\
||w||_\infty = \max_{i} |x_i|
\]</span> <span class="math inline">\(l_0\)</span> norm is a direct
attempt to penalize nonzero parameters. However, <span class="math inline">\(\lambda ||w||_0\)</span> is not continuous at
points when there is a zero entry in <span class="math inline">\(w\)</span>; when <span class="math inline">\(\forall i, w_i \ne 0\)</span>, <span class="math inline">\(\lambda ||w||_0\)</span> does not contribute
gradient at all. There is no analytical way to determine <span class="math inline">\(w_i\)</span> should be zero or not. The only
course open is to manually set each <span class="math inline">\(w_i\)</span> to zero. But this method is
prohibitive in terms of the complexity: there are <span class="math inline">\(2^{|w|}\)</span> combinations to try (there are <a href="https://www.wikiwand.com/en/Matching_pursuit">orthogonal matching
pursuit</a> &lt;??&gt; and <a href="https://www.jmlr.org/papers/volume19/17-194/17-194.pdf">other
methods</a> that try to approximate it though). Thus, the <span class="math inline">\(l_0\)</span> norm is ruled out for
consideration.</p>
<p>Then <span class="math inline">\(l_1\)</span> norm pops up. <span class="math inline">\(l_1\)</span> norm is good since there is an
analytical solution to its gradient w.r.t. <span class="math inline">\(w\)</span>. (why does <span class="math inline">\(l_1\)</span> norm add sparsity?)</p>
<h3 id="structured-sparsity">Structured Sparsity</h3>
<p>Better zero parameters is that zero parameters appear block-wise.
Block-wise zero entries are the essence of sparsity. However, the Lasso
term does not guarantee zero entries appear in block. To amend it,
<strong>group Lasso</strong> trick is invented and the regularized loss
becomes <span class="math display">\[
\hat \ell_w(X, Y) = \ell_w(X, Y) + \sum_j \lambda_j ||\beta_j||_1
\]</span> where <span class="math inline">\(\beta_j\)</span> is the
<span class="math inline">\(l_2\)</span> norm of <span class="math inline">\(j\)</span>-th group of parameters that usually
spatially near.</p>
<p><img src="./structured-sparsity.svg"/></p>
<p>Structured sparsity precedes random sparsity, because random sparsity
does not secure a regular memory access pattern, so that there will be a
poor cache locality. The figure above illustrates from irregular
structured sparsity to regular structured sparsity<a href="#fn19" class="footnote-ref" id="fnref19" role="doc-noteref"><sup>19</sup></a>.
Obviously, regular structured sparsity is preferred so long as it won’t
undermine the model performance much.</p>
<h3 id="nonlinearity-approximationnonlinear-approx">Nonlinearity
Approximation<a href="#fn20" class="footnote-ref" id="fnref20" role="doc-noteref"><sup>20</sup></a></h3>
<p>As mentioned, typical sparsification analyzes the linear regression
problem, which has two components: 1) the model as a linear function; 2)
the MSE loss function. The MSE loss function does well, not among the
best though, in most tasks. But mere linear model won’t do
generally.</p>
<p>Most nonlinearity in nonlinear model comes from the element-wise
function mapping on the tensor obtained by linear transformation of
input, e.g. the response on feature map obtained by convolution (in this
case, <span class="math inline">\(X,w,X w\)</span> will be the
transformed input, kernel and convolution result respectively, as shown
in <a href="#GEMM">GEMM</a> section). Our focus is still on sparsity of
the linear component in the nonlineear model.</p>
<p>The objective becomes <span class="math display">\[
\min_w ||Y - f(X w)||_F
\]</span> where <span class="math inline">\(f\)</span> is a nonlineear
function like <span class="math inline">\(\mathrm{ReLU}\)</span>.</p>
<h2 id="pruning">Pruning</h2>
<p>Pruning is a kind of post-processing trick, which happens after
training, to make parameters more “zero”.</p>
<h3 id="channel-pruning">Channel Pruning</h3>
<p>Channel pruning boils down to the following optimization problem:
<span class="math display">\[
\begin{aligned}
\min_{\beta, W} \quad &amp; \left\Vert Y - \sum_{i} \beta_i X_i W_i
\right\Vert_F^2 \\
\text{s.t.} \quad &amp; ||\beta||_0 \le c&#39;
\end{aligned}
\]</span></p>
<p>Note here that <span class="math inline">\(X_i\)</span> is not the
feature map at <span class="math inline">\(i\)</span>-th channel, but
instead the sampled window of kernel size (<span class="math inline">\(k_h \times k_h\)</span>) on <span class="math inline">\(i\)</span>-th feature map. It is known that this
problem is NP-hard because of the <span class="math inline">\(l_0\)</span> norm term in the constraint. In
practice, it can be relaxed to (why and really?) <span class="math display">\[
\begin{aligned}
\min_{\beta, W} \quad &amp; \left\Vert Y - \sum_{i} \beta_i X_i W_i
\right\Vert_F^2 \\
\text{s.t.} \quad &amp; ||\beta||_1 \le c&#39;&#39; \and \forall i,
||W_i||_F = 1
\end{aligned}
\]</span> Note that kernels <span class="math inline">\(W\)</span> is
also included for optimization. This is because after pruning, kernels
may still be fine-tuned a bit to preserve the accuracy.</p>
<p>The above formula can be optimized in an alternative fashion:
i.e. <span class="math inline">\(W\)</span> is fixed and <span class="math inline">\(\beta\)</span> is to be optimized; then <span class="math inline">\(\beta\)</span> is fixed and <span class="math inline">\(W\)</span> is to be optimized. We also add a
regularization term for each <span class="math inline">\(W_i\)</span>.
This is because optimizing <span class="math inline">\(W\)</span> is
materially a linear regression task, which easily has infinitely many
solution due to the dimension of <span class="math inline">\(X_i\)</span> unless there is an extra
constraint.</p>
<h3 id="low-rank-decomposition">Low-rank Decomposition</h3>
<p>Take the matrix multiplication as an example to appreciate the idea
of low-rank decomposition: <span class="math display">\[
X \times W \Rightarrow X \times U \times V
\]</span> We may decompose <span class="math inline">\(W: m \times
n\)</span> into <span class="math inline">\(U: m \times r\)</span> and
<span class="math inline">\(N: r \times n\)</span> where hopefully <span class="math inline">\(r &lt; n,m\)</span> (note that when <span class="math inline">\(r = \rank W\)</span>, there exists <span class="math inline">\(U\)</span> and <span class="math inline">\(V\)</span> that can fully recover <span class="math inline">\(W\)</span>). In this way, storage cost can be
saved and computation can be sped up.</p>
<p>Note that our objective is not to reconstruct the matrix <span class="math inline">\(W\)</span> (called <strong>matrix
approximation</strong>) with some other lower-rank matrices. Or else
simply the singular value decomposition would do the job. Instead, we
are to reconstruct the model output (called <strong>matrix
regression</strong>). Therefore, the problem is formulated as <span class="math display">\[
\begin{aligned}
\min_{W, A, B} \quad &amp; ||Y -  X W||_F \\
\text{s.t.} \quad &amp; W = U V \\
&amp; \rank U, \rank V \le r
\end{aligned}
\]</span></p>
<h4 id="combination-with-other-methods">Combination with Other
Methods</h4>
<p>Low-rank decomposition can be combined with sparsity and nonlinearity
approximation to give the following ultimate pruning problem: <span class="math display">\[
\begin{aligned}
\min_{W, A, B} \quad &amp; ||Y -  f(X W)||_F \\
\text{s.t.} \quad &amp; W = A + B \\
&amp; ||A||_0 \le S \\
&amp; \rank B \le L \\
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(|| \cdot ||_0\)</span> is the
number of nonzero entries in the matrix.</p>
<p>The sparsity comes from <span class="math inline">\(A\)</span> and
low-rank decomposition comes from <span class="math inline">\(B\)</span>. The above problem is NP-hard due to
the constraints on <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>. We can relax these constraints to
other forms: <span class="math display">\[
\begin{aligned}
\min_{W, A, B} \quad &amp; ||Y -  f(X W)||_F \\
\text{s.t.} \quad &amp; W = A + B \\
&amp; ||A||_{21} \le S  \\
&amp; ||B||_* \le L \\
\end{aligned}
\]</span> where <span class="math inline">\(|| \cdot ||_{21}\)</span>
takes the <span class="math inline">\(l_1\)</span> norm of the <span class="math inline">\(l_2\)</span> norms taken on each column of the
matrix; and <span class="math inline">\(|| \cdot ||_*\)</span> is the
nuclear norm that equals to the sum of singular values.</p>
<p>To solve it, alternating direction method of multipliers (ADMM) can
be adopted. The augmented Lagrangian function is (??) <span class="math display">\[
L(W,A,B,\Lambda) = ||Y -  f(X W)||_F + \lambda_1 ||A||_{21} + \lambda_2
||B||_* + \Lambda \odot (W - A - B) + \frac{\rho}{2}||W - A - B||_F^2
\]</span></p>
<h4 id="tensor-decomposition">Tensor Decomposition</h4>
<p>Tucker decomp, CP decomp, Tucker-2 (or TT) decomp</p>
<h2 id="quantizationquant-pytorch">Quantization<a href="#fn21" class="footnote-ref" id="fnref21" role="doc-noteref"><sup>21</sup></a></h2>
<p>Model parameters are natively floating-point numbers. During
training, model parameters usually won’t be too large and won’t exceed
the range of <code>int8</code>. One way to make the model smaller and
run faster is to map model parameters to integers of smaller size (say
from <code>fp32</code> to <code>int16</code>).</p>
<p>Other than the efficiency perspective, if the original values span a
very narrow range (say from -10 to 10), by mapping them to a wider range
of integers, better precision may even be obtained. This is mainly due
to that most floating-point number arithmetic suffer from precision
loss. Particularly, when two floating-point numbers of significant
difference adds or subtracts, a great loss in precision can occur
(called <strong>catastrophic cancellation</strong>).</p>
<p>After integer arithmetic, we can map these integer values back again.
The process involved is called
<strong>quantization/dequantization</strong>. For a number <span class="math inline">\(r\)</span>, its quantization is <span class="math inline">\(Q(r) = \text{Int}(r/k) - b\)</span> where <span class="math inline">\(k\)</span> is the scale and <span class="math inline">\(b\)</span> is the bias. To dequantize, <span class="math inline">\(\hat r = k(Q(r) + b)\)</span>.</p>
<p><img src="./quant_sym.png"/></p>
<p><img src="./quant_asym.png"/></p>
<p>The first question to consider <strong>symmetric quantization or
asymmetric quantization</strong> (the figure above). That is, should the
zero in the original domain mapped to zero or <span class="math inline">\(-b\)</span> (because <span class="math inline">\(\text{Int}(0/k)-b = -b\)</span>). In essence, this
is a question of choice of bias. Preferring to computation efficiency,
we hope bias is zero. To show it, consider the dequantization process of
the matrix product: <span class="math display">\[
A = k_A \times A_Q + b_A \\
B = k_B \times B_Q + b_B \\
A B = k_A k_B A_Q B_Q + k_A b_B A_Q ＋ k_B b_A B_Q + b_A b_B
\]</span> It would have been cleaner if <span class="math inline">\(b_A,
b_B\)</span> are zero. However, if the activations in the network are
mostly non-negative, like in the case where ReLU is used, symmetric
quantization would waste half of the quantization range.</p>
<p>The second question is to consider using the <strong>restricted range
or the full range</strong> of the target integer type. Take
<code>int8</code> for an example, should we map numbers to <span class="math inline">\([-127, 127]\)</span> or <span class="math inline">\([-128, 127]\)</span>? When symmetric quantization
is used, the answer is the restricted range. The reason is that, the
quantization of two numbers of the same magnitude but different signs,
should be of the same magnitude but different signs too. But had the
full range been used, supposing the floating-point range was <span class="math inline">\([-2.2, 2.2]\)</span>, <span class="math inline">\(2.2\)</span> and <span class="math inline">\(-2.2\)</span> would have been quantized into <span class="math inline">\(2.2 \times \frac{127}{2.2} = 127\)</span> and
<span class="math inline">\(-2.2 \times \frac{128}{2.2} = -128\)</span>
respectively. The problem is that the scaling factors for positive
number and negative number are different due to the asymmetric range, in
which case a small bias would be introduced and leads to precision
loss.</p>
<p>The third question is the timing of quantization. Should the
quantization happen during training (<strong>quantization-aware
training</strong>) or after training (<strong>post-training
quantization</strong>)? Accompanying this question is what the best
scale should be.</p>
<ul>
<li><p>Post-training (static) quantization (PTQ)</p>
<p><img src="./ptq.svg" style="zoom: 25%;"/></p>
<p>In PTQ, model are trained before quantized. After training, a small
subset of training data (called <strong>calibration data</strong>) is
used to determine the scale (magnitude) and the clipping range
(quantization bit number). Notice that model parameters are fixed in
this process.</p></li>
<li><p>Quantization-aware training (QAT)</p>
<p><img src="./qat.svg" style="zoom:25%;"/></p>
<p>In QAT, model parameters are quantized and then trained. QAT brings a
great save in computation during training. But this yields another
question: should the quantization happen during forward pass or during
back propagation?</p>
<p>Quantization is used in forward pass but not in back propagation. The
reason not to update gradient in quantized domain is that, numbers in
quantized domain are integers but gradient is fractional. Another reason
not to back-propagate in quantized domain is that, the gradient might be
so large as to disturb the convergence of model, compared with that in
dequantized domain.</p>
<p>The error is measured between the dequantized output and the target
output. Model parameters will update in dequantized format and will be
re-quantized for next round of training. There are arguments on both
sides for this approach. One good aspect is that it takes the
quantization error into consideration. But this causes the gradient
mismatch because the gradient of the parameters are computed with
quantized values but updated in dequantized format. In worst case, this
may cause the model to diverge.</p>
<p>This training method reconciles with the idea of stochastic neuron,
where back propagation is done by <strong>straight-through
estimator</strong> (STE)<a href="#fn22" class="footnote-ref" id="fnref22" role="doc-noteref"><sup>22</sup></a>. There is another
method based on STE and called <strong>parameterized clipping
activation</strong> (PACT)<a href="#fn23" class="footnote-ref" id="fnref23" role="doc-noteref"><sup>23</sup></a>. The meat of PACT is a
learnable ReLU function: <span class="math display">\[
y = \mathrm{PACT}(x, \alpha) = 0.5 (|x| - |x-\alpha| + \alpha) =
\begin{cases}
0, &amp; x \le 0 \\
x, &amp; 0 &lt; x &lt; \alpha \\
\alpha, &amp; x \ge \alpha
\end{cases}
\]</span> Back-propagation is done w.r.t. the dequantized value <span class="math inline">\(y_{dq} \triangleq \lfloor y \cdot \frac{2^k -
1}{\alpha} \rfloor \frac{\alpha}{2^k - 1}\)</span>. <span class="math inline">\(\frac{\partial y_{dq}}{\partial y}\)</span> is set
to <span class="math inline">\(\frac{\text{range before
quant.}}{\text{range of quant. domain}}\)</span> as would be in STE.
<span class="math inline">\(\alpha\)</span> is learnable so that
clipping range can be dynamically adjusted: <span class="math display">\[
\frac{\partial y}{\partial \alpha} =
\begin{cases}
0, &amp; x &lt; \alpha \\
1, &amp; x \ge \alpha
\end{cases}
\]</span></p></li>
</ul>
<p>The fourth question is the granularity of quantization. There are
usually three kinds of choices, namely channel-wise, layer-wise and
group-wise quantization.</p>
<h3 id="bnntnnbnn">BNN/TNN<a href="#fn24" class="footnote-ref" id="fnref24" role="doc-noteref"><sup>24</sup></a></h3>
<p>Binarized and ternary neural network bring quantization to an
extreme. The reason to particularly split them out under <a href="#quantization">quantization</a> is that, their multiplication and
addition logic are quite different. They use 1 bit and 2 bits for
clipping: BNN maps values to -1 and 1; TNN maps values to -1, 0 and 1.
Then the multiplication and addition only involve Boolean operations,
which will be much faster. Other than that, the training process of
BNN/TNN resembles that of quantization.</p>
<p>The motivation behind is that model parameters are usually within
<span class="math inline">\([-1, 1]\)</span>. So why not try just using
-1, 0 and 1? Given a weight matrix <span class="math inline">\(W\)</span> (squeezed into an <span class="math inline">\(\R^n\)</span> vector), there is an analytical
solution to the best scaling factor <span class="math inline">\(k\)</span> and the quantized value <span class="math inline">\(B\)</span> (squeezed into an <span class="math inline">\(\R^n\)</span> vector) for BNN:</p>
<p><span class="math display">\[
\begin{aligned}
B^* &amp;= \arg \min_{B} \| W - kB \|_2 = \arg \min_{B} \| W - kB \|_2^2
\\
&amp;= \arg \min_{B} W^T W - 2 k W^T B + k^2 B^T B \\
\end{aligned}
\]</span> Since <span class="math inline">\(W\)</span> is known and
<span class="math inline">\(B \in \{ -1, 1 \}^n\)</span>, <span class="math inline">\(W^T W\)</span> is a constant <span class="math inline">\(c\)</span> and <span class="math inline">\(B^T
B\)</span> is <span class="math inline">\(n\)</span>. Thus, <span class="math display">\[
\begin{gathered}
B^* = \arg \min_{B} k^2 n + c - 2 k W^T B = \mathrm{sign}(W) \\
k = \frac{W^T B^*}{n}
\end{gathered}
\]</span></p>
<h2 id="knowledge-distillation">Knowledge Distillation</h2>
<p>Knowledge distillation is a model compression method in which a
smaller model is trained to mimic the pre-trained larger model. The
larger and the smaller model are referred to as “teacher” and “student”
respectively.</p>
<p>There are three kinds of distillation methods:</p>
<ol type="1">
<li><p>Response-based knowledge</p>
<p>This is perhaps the easiest one to think of: given the same input,
the output (usually a categorical distribution) should be the same.</p>
<p>In this case, the distillation loss is set to be the cross entropy
between the distributions output by the teacher and the student.
Minimizing the cross entropy between the output distributions
equivalently minimizes the their KL-divergence, given that teacher’s
distribution is fixed.</p>
<p>On the other hand, the student model can further be rectified by the
ground-truth loss.</p></li>
<li><p>Feature-based knowledge</p></li>
<li><p>Relation-based knowledge</p></li>
</ol>
<h2 id="network-architecture-search">Network Architecture Search</h2>
<p>There are mainly two indexes for a network: one is the
<strong>latency</strong> and the other is <strong>accuracy</strong>. In
NAS, latency is cheaper to check upon than accuracy, since the training
is more time-consuming than a single pass of input.</p>
<p>NAS is mostly based on heuristics. During training, we can save time
by</p>
<ul>
<li>early stop</li>
<li>warm restart (parameter reuse)</li>
<li>use the arrogate target like FLOPs (which is usually proportional to
latency)</li>
</ul>
<p>As for searching in the solution space, we can do with</p>
<ul>
<li>grid search</li>
<li>random sampling</li>
<li>reinforcement learning</li>
<li>evolutional algorithm</li>
<li>Bayesian optimization like Gaussian process</li>
</ul>
<h1 id="useful-links">Useful Links</h1>
<p>Related courses:</p>
<ul>
<li><a href="https://sites.cs.ucsb.edu/~tyang/class/240a17/">CS240A -
Applied Parallel Computing (ucsb.edu)</a></li>
<li><a href="https://hanlab.mit.edu/courses/2023-fall-65940">MIT 6.5940
Fall 2023 TinyML and Efficient Deep Learning Computing</a></li>
</ul>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr/>
<ol>
<li id="fn1" role="doc-endnote"><p>https://arxiv.org/abs/1911.05662<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>https://arxiv.org/abs/1706.06873<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>https://ieeexplore.ieee.org/document/10144741<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>https://tvm.apache.org/docs/how_to/optimize_operators/opt_gemm.html<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>https://ieeexplore.ieee.org/document/6877334<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>https://spatial-lang.org/dotprod<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>http://csapp.cs.cmu.edu/3e/waside/waside-blocking.pdf<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>https://penny-xu.github.io/blog/tiled-matrix-multiplication<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>https://docs.juliahub.com/LoopVectorization/4TogI/0.9.8/examples/matrix_multiplication/<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>https://www.youtube.com/watch?v=8zbh4gWGa7I&amp;t=424s<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>https://arxiv.org/abs/2002.12418<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn12" role="doc-endnote"><p>https://www.youtube.com/watch?v=DruwS2_cVys<a href="#fnref12" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn13" role="doc-endnote"><p>https://martin-thoma.com/strassen-algorithm-in-python-java-cpp/<a href="#fnref13" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn14" role="doc-endnote"><p>https://www.diva-portal.org/smash/get/diva2:1219121/FULLTEXT01.pdf<a href="#fnref14" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn15" role="doc-endnote"><p>https://arxiv.org/abs/1509.09308<a href="#fnref15" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn16" role="doc-endnote"><p>https://ceca.pku.edu.cn/docs/20191126112405101722.pdf<a href="#fnref16" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn17" role="doc-endnote"><p><a href="https://towardsdatascience.com/how-does-sparse-convolution-work-3257a0a8fd1">How
does sparse convolution work? | by Zhiliang Zhou | Towards Data
Science</a><a href="#fnref17" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn18" role="doc-endnote"><p><a href="https://rancheng.github.io/Sparse-Convolution-Explained/">Sparse
Convolution explained with code – Ran Cheng – Robotics, Vision,
Learning.</a><a href="#fnref18" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn19" role="doc-endnote"><p>https://arxiv.org/pdf/1705.08922.pdf<a href="#fnref19" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn20" role="doc-endnote"><p>https://arxiv.org/abs/1411.4229<a href="#fnref20" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn21" role="doc-endnote"><p>https://pytorch.org/blog/quantization-in-practice/<a href="#fnref21" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn22" role="doc-endnote"><p>https://arxiv.org/abs/1308.3432<a href="#fnref22" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn23" role="doc-endnote"><p>https://arxiv.org/abs/1805.06085<a href="#fnref23" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn24" role="doc-endnote"><p>https://arxiv.org/abs/1603.05279<a href="#fnref24" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>



          </div>

          



          
          
          <div class="article-widget">
            
<div class="post-nav">
  
  
</div>

          </div>
          
        </div>

        <div class="body-footer">
          <p>Last updated on Jan 7, 2022</p>

          



          




          


        </div>

      </article>

      <footer class="site-footer">

  



  

  

  

  
  






  
  
  

  
  
    
  
  
    
  

  

  
  <p class="powered-by copyright-license-text">
    © 2024 Chunxy. This work is licensed under <a href="https://creativecommons.org/licenses/by-nc-nd/4.0" rel="noopener noreferrer" target="_blank">CC BY NC ND 4.0</a>
  </p>
  

  <p class="powered-by footer-license-icons">
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0" rel="noopener noreferrer" target="_blank" aria-label="Creative Commons">
      <i class="fab fa-creative-commons fa-2x" aria-hidden="true"></i>
      <i class="fab fa-creative-commons-by fa-2x" aria-hidden="true"></i>
      
        <i class="fab fa-creative-commons-nc fa-2x" aria-hidden="true"></i>
      
      
        <i class="fab fa-creative-commons-nd fa-2x" aria-hidden="true"></i>
      
    </a>
  </p>




  <p class="powered-by">
    
    
    
      
      
      
      
      
      
      Published with <a href="https://wowchemy.com/?utm_campaign=poweredby" target="_blank" rel="noopener">Wowchemy</a> — the free, <a href="https://github.com/wowchemy/wowchemy-hugo-themes" target="_blank" rel="noopener">open source</a> website builder that empowers creators.
    
  </p>
</footer>


    </main>
  </div>
</div>

  </div>

  <div class="page-footer">
    
    
  </div>

      

    
    <script src="/js/vendor-bundle.min.6b237408b24ab0ca6e1a289724ba42ac.js"></script>

    
    
    
      

      
      

      

    

    
    
    

    
    
    <script src="https://cdn.jsdelivr.net/gh/bryanbraun/anchorjs@4.2.2/anchor.min.js" integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    
    
    
      
      <script id="search-hit-fuse-template" type="text/x-template">
        <div class="search-hit" id="summary-{{key}}">
          <div class="search-hit-content">
            <div class="search-hit-name">
              <a href="{{relpermalink}}">{{title}}</a>
              <div class="article-metadata search-hit-type">{{type}}</div>
              <p class="search-hit-description">{{snippet}}</p>
            </div>
          </div>
        </div>
      </script>
      
        <script src="https://cdn.jsdelivr.net/gh/krisk/Fuse@v3.2.1/dist/fuse.min.js" integrity="sha512-o38bmzBGX+hD3JHWUFCDA09btWaqrNmoJ3RXLlrysA7PP01Kgs4UlE4MhelE1v5dJR3+cxlR4qQlotsW7jKsnw==" crossorigin="anonymous"></script>
        <script src="https://cdn.jsdelivr.net/gh/julmot/mark.js@8.11.1/dist/jquery.mark.min.js" integrity="sha512-mhbv5DqBMgrWL+32MmsDOt/OAvqr/cHimk6B8y/bx/xS88MVkYGPiVv2ixKVrkywF2qHplNRUvFsAHUdxZ3Krg==" crossorigin="anonymous"></script>
      
    

    
    

    
    
    
    

    
    
      
      
      
      
      
      
      
    

    

    
    
    
    <script id="page-data" type="application/json">{"use_headroom":false}</script>

    
    
    
    
    
    
    
    
    
    
      
      
    
    
    <script src="/en/js/wowchemy.min.06ae91c9ae146f7126c01e6cceb0a4a6.js"></script>

    
    
    
    
    
    






</body>
</html>
